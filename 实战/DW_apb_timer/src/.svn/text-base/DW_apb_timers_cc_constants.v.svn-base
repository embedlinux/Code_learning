/*
------------------------------------------------------------------------
--
--                   (C) COPYRIGHT 2001-2010 SYNOPSYS INC.
--                             ALL RIGHTS RESERVED
--
--  This software and the associated documentation are confidential and
--  proprietary to Synopsys, Inc.  Your use or disclosure of this software
--  is subject to the terms and conditions of a written license agreement
--  between you, or your company, and Synopsys, Inc.
--
--  The entire notice above must be reproduced on all authorized copies.
--
-- File         : DW_apb_timers_cc_constants.v
-- Version      : $Revision: #3 $
-- Abstract     : Configuration Parameters for DW_apb_timers 
--
------------------------------------------------------------------------
*/

// Name:         APB_DATA_WIDTH
// Default:      32
// Values:       8 16 32
// 
// Width of APB Data Bus to which this component is attached
`define APB_DATA_WIDTH 32


`define APB_DW_EQ_32


// `define APB_DW_EQ_16


// `define APB_DW_EQ_8


// Name:         TIM_NEWMODE
// Default:      0
// Values:       0, 1
// Enabled:      (APB_DATA_WIDTH==32)
// 
// Operates the timer in a new mode of operation 
// Only available in 32 bit APB mode
// `define TIM_NEWMODE


`define TIM_NEWMODE_VAL 0


// Name:         NUM_TIMERS
// Default:      2
// Values:       1 2 3 4 5 6 7 8
// 
// Number of Timers to instantiate  
// in DW_apb_timers.  Up to eight timers can be instantiated.
`define NUM_TIMERS 2


`define NUM_TIMERS_GTE_1


`define NUM_TIMERS_GTE_2


// `define NUM_TIMERS_GTE_3


// `define NUM_TIMERS_GTE_4


// `define NUM_TIMERS_GTE_5


// `define NUM_TIMERS_GTE_6


// `define NUM_TIMERS_GTE_7


// `define NUM_TIMERS_GTE_8

//Polarity of interrupt signals generated by DW_apb_timers

// Name:         TIM_INTRPT_PLRITY
// Default:      Active High
// Values:       Active Low (0), Active High (1)
// Enabled:      (TIM_NEWMODE==0)
`define TIM_INTRPT_PLRITY 1


// Name:         TIM_INTR_IO
// Default:      false
// Values:       false (0), true (1)
// Enabled:      (TIM_NEWMODE==0)
// 
// This selects whether this component generates an interrupt output flag for  
// each timer instantiated or a single interrupt output flag covering all  
// timers in the component.
`define TIM_INTR_IO 0


// Name:         TIMER_WIDTH_1
// Default:      32
// Values:       8, ..., 32
// 
//  
// Width of Timer 
// Timers can be between 8 and 32 bits wide (inclusive).
`define TIMER_WIDTH_1 32


// Name:         TIMER_HAS_TOGGLE_1
// Default:      false
// Values:       false (0), true (1)
// 
// Include an output which toggles each time the counter reloads. 
// Disabled to zero each time the timer is disabled.
`define TIMER_HAS_TOGGLE_1 0


// Name:         TIM_METASTABLE_1
// Default:      Absent ((TIM_NEWMODE))
// Values:       Absent (0), Present (1)
// Enabled:      (TIM_NEWMODE==0)
// 
//  
// Set this parameter to "Present" if you 
// want metastability flops instantiated on this timer's internal interrupt flag 
// on the boundary between this timer's clock and the bus clock domain.
`define TIM_METASTABLE_1 0


// Name:         TIM_PULSE_EXTD_1
// Default:      0
// Values:       0 1 2 3
// Enabled:      (TIM_NEWMODE==0)
// 
//  
// Pulse Extension Control 
// If this timer's clock is faster than the system bus clock, you can extend 
// the internal interrupt flag by up to three timer clock cycles to guarantee 
// that it is seen in the bus clock domain.  A zero value in this field means 
// that no pulse extension is to be performed.
`define TIM_PULSE_EXTD_1 0


// Name:         TIM_COHERENCY_1
// Default:      false
// Values:       false (0), true (1)
// Enabled:      APB_DATA_WIDTH < TIMER_WIDTH_1
// 
// Adds a bank of registers between 
// this timer and the APB interface of DW_apb_timers to guarantee that 
// the timer value read back from this block is coherent - i.e. it does 
// not reflect ongoing changes in the timer's value which take place while 
// the read operation is in progress.  Note that including coherency can 
// dramatically increase the register count of the design. Note also 
// that coherency will not be implemented if the timer width is less 
// than or equal to the APB Data Width
`define TIM_COHERENCY_1 0


// Name:         TIMER_WIDTH_2
// Default:      32
// Values:       8, ..., 32
// Enabled:      NUM_TIMERS > 1
// 
// Width of Timer 
// Timers can be between 8 and 32 bits wide (inclusive).
`define TIMER_WIDTH_2 32


// Name:         TIMER_HAS_TOGGLE_2
// Default:      false
// Values:       false (0), true (1)
// Enabled:      NUM_TIMERS > 1
// 
// Include an output which toggles each time the counter reloads. 
// Disabled to zero each time the timer is disabled.
`define TIMER_HAS_TOGGLE_2 0


// Name:         TIM_METASTABLE_2
// Default:      Absent ((TIM_NEWMODE))
// Values:       Absent (0), Present (1)
// Enabled:      (TIM_NEWMODE==0)
// 
// Set this parameter to "Present" if you 
// want metastability flops instantiated on this timer's internal interrupt flag 
// on the boundary between this timer's clock and the bus clock domain.
`define TIM_METASTABLE_2 0


// Name:         TIM_PULSE_EXTD_2
// Default:      0
// Values:       0 1 2 3
// Enabled:      (TIM_NEWMODE==0)
// 
// Pulse Extension Control 
// If this timer's clock is faster than the system bus clock, you can extend 
// the internal interrupt flag by up to three timer clock cycles to guarantee 
// that it is seen in the bus clock domain.  A zero value in this field means 
// that no pulse extension is to be performed.
`define TIM_PULSE_EXTD_2 0


// Name:         TIM_COHERENCY_2
// Default:      false
// Values:       false (0), true (1)
// Enabled:      NUM_TIMERS >= 2 && APB_DATA_WIDTH < TIMER_WIDTH_2
// 
// Adds a bank of registers between 
// this timer and the APB interface of DW_apb_timers to guarantee that 
// the timer value read back from this block is coherent - i.e. it does 
// not reflect ongoing changes in the timer's value which take place while 
// the read operation is in progress.  Note that including coherency can 
// dramatically increase the register count of the design. Note also 
// that coherency will not be implemented if the timer width is less 
// than or equal to the APB Data Width
`define TIM_COHERENCY_2 0


// Name:         TIMER_WIDTH_3
// Default:      32
// Values:       8, ..., 32
// Enabled:      NUM_TIMERS > 2
// 
// Width of Timer 
// Timers can be between 8 and 32 bits wide (inclusive).
`define TIMER_WIDTH_3 32


// Name:         TIMER_HAS_TOGGLE_3
// Default:      false
// Values:       false (0), true (1)
// Enabled:      NUM_TIMERS > 2
// 
// Include an output which toggles each time the counter reloads. 
// Disabled to zero each time the timer is disabled.
`define TIMER_HAS_TOGGLE_3 0


// Name:         TIM_METASTABLE_3
// Default:      Absent ((TIM_NEWMODE))
// Values:       Absent (0), Present (1)
// Enabled:      (TIM_NEWMODE==0)
// 
// Set this parameter to "Present" if you 
// want metastability flops instantiated on this timer's internal interrupt flag 
// on the boundary between this timer's clock and the bus clock domain.
`define TIM_METASTABLE_3 0


// Name:         TIM_PULSE_EXTD_3
// Default:      0
// Values:       0 1 2 3
// Enabled:      (TIM_NEWMODE==0)
// 
// Pulse Extension Control 
// If this timer's clock is faster than the system bus clock, you can extend 
// the internal interrupt flag by up to three timer clock cycles to guarantee 
// that it is seen in the bus clock domain.  A zero value in this field means 
// that no pulse extension is to be performed.
`define TIM_PULSE_EXTD_3 0


// Name:         TIM_COHERENCY_3
// Default:      false
// Values:       false (0), true (1)
// Enabled:      NUM_TIMERS >= 3 && APB_DATA_WIDTH < TIMER_WIDTH_3
// 
// Adds a bank of registers between 
// this timer and the APB interface of DW_apb_timers to guarantee that 
// the timer value read back from this block is coherent - i.e. it does 
// not reflect ongoing changes in the timer's value which take place while 
// the read operation is in progress.  Note that including coherency can 
// dramatically increase the register count of the design. Note also 
// that coherency will not be implemented if the timer width is less 
// than or equal to the APB Data Width
`define TIM_COHERENCY_3 0


// Name:         TIMER_WIDTH_4
// Default:      32
// Values:       8, ..., 32
// Enabled:      NUM_TIMERS > 3
// 
// Width of Timer 
// Timers can be between 8 and 32 bits wide (inclusive).
`define TIMER_WIDTH_4 32


// Name:         TIMER_HAS_TOGGLE_4
// Default:      false
// Values:       false (0), true (1)
// Enabled:      NUM_TIMERS > 3
// 
// Include an output which toggles each time the counter reloads. 
// Disabled to zero each time the timer is disabled.
`define TIMER_HAS_TOGGLE_4 0


// Name:         TIM_METASTABLE_4
// Default:      Absent ((TIM_NEWMODE))
// Values:       Absent (0), Present (1)
// Enabled:      (TIM_NEWMODE==0)
// 
// Set this parameter to "Present" if you 
// want metastability flops instantiated on this timer's internal interrupt flag 
// on the boundary between this timer's clock and the bus clock domain.
`define TIM_METASTABLE_4 0


// Name:         TIM_PULSE_EXTD_4
// Default:      0
// Values:       0 1 2 3
// Enabled:      (TIM_NEWMODE==0)
// 
// Pulse Extension Control 
// If this timer's clock is faster than the system bus clock, you can extend 
// the internal interrupt flag by up to three timer clock cycles to guarantee 
// that it is seen in the bus clock domain.  A zero value in this field means 
// that no pulse extension is to be performed.
`define TIM_PULSE_EXTD_4 0


// Name:         TIM_COHERENCY_4
// Default:      false
// Values:       false (0), true (1)
// Enabled:      NUM_TIMERS >= 4 && APB_DATA_WIDTH < TIMER_WIDTH_4
// 
// Adds a bank of registers between 
// this timer and the APB interface of DW_apb_timers to guarantee that 
// the timer value read back from this block is coherent - i.e. it does 
// not reflect ongoing changes in the timer's value which take place while 
// the read operation is in progress.  Note that including coherency can 
// dramatically increase the register count of the design. Note also 
// that coherency will not be implemented if the timer width is less 
// than or equal to the APB Data Width
`define TIM_COHERENCY_4 0


// Name:         TIMER_WIDTH_5
// Default:      32
// Values:       8, ..., 32
// Enabled:      NUM_TIMERS > 4
// 
// Width of Timer 
// Timers can be between 8 and 32 bits wide (inclusive).
`define TIMER_WIDTH_5 32


// Name:         TIMER_HAS_TOGGLE_5
// Default:      false
// Values:       false (0), true (1)
// Enabled:      NUM_TIMERS > 4
// 
// Include an output which toggles each time the counter reloads. 
// Disabled to zero each time the timer is disabled.
`define TIMER_HAS_TOGGLE_5 0


// Name:         TIM_METASTABLE_5
// Default:      Absent ((TIM_NEWMODE))
// Values:       Absent (0), Present (1)
// Enabled:      (TIM_NEWMODE==0)
// 
// Set this parameter to "Present" if you 
// want metastability flops instantiated on this timer's internal interrupt flag 
// on the boundary between this timer's clock and the bus clock domain.
`define TIM_METASTABLE_5 0


// Name:         TIM_PULSE_EXTD_5
// Default:      0
// Values:       0 1 2 3
// Enabled:      (TIM_NEWMODE==0)
// 
// Pulse Extension Control 
// If this timer's clock is faster than the system bus clock, you can extend 
// the internal interrupt flag by up to three timer clock cycles to guarantee 
// that it is seen in the bus clock domain.  A zero value in this field means 
// that no pulse extension is to be performed.
`define TIM_PULSE_EXTD_5 0


// Name:         TIM_COHERENCY_5
// Default:      false
// Values:       false (0), true (1)
// Enabled:      NUM_TIMERS >= 5 && APB_DATA_WIDTH < TIMER_WIDTH_5
// 
// Adds a bank of registers between 
// this timer and the APB interface of DW_apb_timers to guarantee that 
// the timer value read back from this block is coherent - i.e. it does 
// not reflect ongoing changes in the timer's value which take place while 
// the read operation is in progress.  Note that including coherency can 
// dramatically increase the register count of the design. Note also 
// that coherency will not be implemented if the timer width is less 
// than or equal to the APB Data Width
`define TIM_COHERENCY_5 0


// Name:         TIMER_WIDTH_6
// Default:      32
// Values:       8, ..., 32
// Enabled:      NUM_TIMERS > 5
// 
// Width of Timer 
// Timers can be between 8 and 32 bits wide (inclusive).
`define TIMER_WIDTH_6 32


// Name:         TIMER_HAS_TOGGLE_6
// Default:      false
// Values:       false (0), true (1)
// Enabled:      NUM_TIMERS > 5
// 
// Include an output which toggles each time the counter reloads. 
// Disabled to zero each time the timer is disabled.
`define TIMER_HAS_TOGGLE_6 0


// Name:         TIM_METASTABLE_6
// Default:      Absent ((TIM_NEWMODE))
// Values:       Absent (0), Present (1)
// Enabled:      (TIM_NEWMODE==0)
// 
//  
// Set this parameter to "Present" if you want metastability flops instantiated  
// on this timer's internal interrupt flag on the boundary between this timer's  
// clock and the bus clock domain.
`define TIM_METASTABLE_6 0


// Name:         TIM_PULSE_EXTD_6
// Default:      0
// Values:       0 1 2 3
// Enabled:      (TIM_NEWMODE==0)
// 
// Pulse Extension Control 
// If this timer's clock is faster than the system bus clock, you can extend 
// the internal interrupt flag by up to three timer clock cycles to guarantee 
// that it is seen in the bus clock domain.  A zero value in this field means 
// that no pulse extension is to be performed.
`define TIM_PULSE_EXTD_6 0


// Name:         TIM_COHERENCY_6
// Default:      false
// Values:       false (0), true (1)
// Enabled:      NUM_TIMERS >= 6 && APB_DATA_WIDTH < TIMER_WIDTH_6
// 
// Adds a bank of registers between 
// this timer and the APB interface of DW_apb_timers to guarantee that 
// the timer value read back from this block is coherent - i.e. it does 
// not reflect ongoing changes in the timer's value which take place while 
// the read operation is in progress.  Note that including coherency can 
// dramatically increase the register count of the design. Note also 
// that coherency will not be implemented if the timer width is less 
// than or equal to the APB Data Width
`define TIM_COHERENCY_6 0


// Name:         TIMER_WIDTH_7
// Default:      32
// Values:       8, ..., 32
// Enabled:      NUM_TIMERS > 6
// 
// Width of Timer 
// Timers can be between 8 and 32 bits wide (inclusive).
`define TIMER_WIDTH_7 32


// Name:         TIMER_HAS_TOGGLE_7
// Default:      false
// Values:       false (0), true (1)
// Enabled:      NUM_TIMERS > 6
// 
// Include an output which toggles each time the counter reloads. 
// Disabled to zero each time the timer is disabled.
`define TIMER_HAS_TOGGLE_7 0


// Name:         TIM_METASTABLE_7
// Default:      Absent ((TIM_NEWMODE))
// Values:       Absent (0), Present (1)
// Enabled:      (TIM_NEWMODE==0)
// 
// Set this parameter to "Present" if you 
// want metastability flops instantiated on this timer's internal interrupt flag 
// on the boundary between this timer's clock and the bus clock domain.
`define TIM_METASTABLE_7 0


// Name:         TIM_PULSE_EXTD_7
// Default:      0
// Values:       0 1 2 3
// Enabled:      (TIM_NEWMODE==0)
// 
// Pulse Extension Control 
// If this timer's clock is faster than the system bus clock, you can extend 
// the internal interrupt flag by up to three timer clock cycles to guarantee 
// that it is seen in the bus clock domain.  A zero value in this field means 
// that no pulse extension is to be performed.
`define TIM_PULSE_EXTD_7 0


// Name:         TIM_COHERENCY_7
// Default:      false
// Values:       false (0), true (1)
// Enabled:      NUM_TIMERS >= 7 && APB_DATA_WIDTH < TIMER_WIDTH_7
// 
// Adds a bank of registers between 
// this timer and the APB interface of DW_apb_timers to guarantee that 
// the timer value read back from this block is coherent - i.e. it does 
// not reflect ongoing changes in the timer's value which take place while 
// the read operation is in progress.  Note that including coherency can 
// dramatically increase the register count of the design. Note also 
// that coherency will not be implemented if the timer width is less 
// than or equal to the APB Data Width
`define TIM_COHERENCY_7 0


// Name:         TIMER_WIDTH_8
// Default:      32
// Values:       8, ..., 32
// Enabled:      NUM_TIMERS > 7
// 
// Width of Timer 
// Timers can be between 8 and 32 bits wide (inclusive).
`define TIMER_WIDTH_8 32


// Name:         TIMER_HAS_TOGGLE_8
// Default:      false
// Values:       false (0), true (1)
// Enabled:      NUM_TIMERS > 7
// 
// TIMER_AS_TOGGLE_8: 
// Include an output which toggles each time the counter reloads. 
// Disabled to zero each time the timer is disabled.
`define TIMER_HAS_TOGGLE_8 0


// Name:         TIM_METASTABLE_8
// Default:      Absent ((TIM_NEWMODE))
// Values:       Absent (0), Present (1)
// Enabled:      (TIM_NEWMODE==0)
// 
// Set this parameter to "Present" if you 
// want metastability flops instantiated on this timer's internal interrupt flag 
// on the boundary between this timer's clock and the bus clock domain.
`define TIM_METASTABLE_8 0


// Name:         TIM_PULSE_EXTD_8
// Default:      0
// Values:       0 1 2 3
// Enabled:      (TIM_NEWMODE==0)
// 
// Pulse Extension Control 
// If this timer's clock is faster than the system bus clock, you can extend 
// the internal interrupt flag by up to three timer clock cycles to guarantee 
// that it is seen in the bus clock domain.  A zero value in this field means 
// that no pulse extension is to be performed.
`define TIM_PULSE_EXTD_8 0


// Name:         TIM_COHERENCY_8
// Default:      false
// Values:       false (0), true (1)
// Enabled:      NUM_TIMERS >= 8 && APB_DATA_WIDTH < TIMER_WIDTH_8
// 
// Adds a bank of registers between 
// this timer and the APB interface of DW_apb_timers to guarantee that 
// the timer value read back from this block is coherent - i.e. it does 
// not reflect ongoing changes in the timer's value which take place while 
// the read operation is in progress.  Note that including coherency can 
// dramatically increase the register count of the design. Note also 
// that coherency will not be implemented if the timer width is less 
// than or equal to the APB Data Width
`define TIM_COHERENCY_8 0


`define TIM_ADDR_SLICE_RHS 2


// Name:         TIM_ADDR_SLICE_LHS
// Default:      7
// Values:       -2147483648, ..., 2147483647
// 
// MSB of decoded address
`define TIM_ADDR_SLICE_LHS 7


// Name:         TIM_WDATA_WIDTH
// Default:      32 (value changes dynamically based on a command)
// Values:       8, ..., 32
// 
// Width of DW_apb_timers' Write Data Bus. 
// If the APB Data Bus Width configured above is wider than the widest timer,  
// this component will have a Write Data Bus Width equal to the width of the 
// widest timer.  If the APB Data Bus Width is narrower than the widest 
// timer, the component's Write Data Bus width will equal that of the APB 
// Data Bus.
`define TIM_WDATA_WIDTH 32


// Name:         TIM_RDATA_WIDTH
// Default:      32 ((=[calc_tim_wdata_width APB_DATA_WIDTH ]))
// Values:       8, ..., =@APB_DATA_WIDTH
// 
// Width of DW_apb_timers' Read Data Bus 
// This is equal to the component's Write Data Bus width.
`define TIM_RDATA_WIDTH 32


// Name:         MAX_APB_DATA_WIDTH
// Default:      32
// Values:       -2147483648, ..., 2147483647
// 
// Bits to decode on paddr
`define MAX_APB_DATA_WIDTH 32


`define TIM_CTL_WIDTH 3


`define TIM_MAX_TIMER_WIDTH 32


`define TIM_MAX_TIMERS_WIDTH 1024


// `define TIM_RC_1


// `define TIM_RC_2


// `define TIM_RC_3


// `define TIM_RC_4


// `define TIM_RC_5


// `define TIM_RC_6


// `define TIM_RC_7


// `define TIM_RC_8


`define TIM_FREE_RUNNING 0


`define TIM_USER_DEFINED 1


`define TIM_MAX_TIMERS 8


`define MAX_CURRVALUE_WIDTH 256


`define TIM1_CV_INDEX 32


`define TIM2_CV_INDEX 64


`define TIM3_CV_INDEX 96


`define TIM4_CV_INDEX 128


`define TIM5_CV_INDEX 160


`define TIM6_CV_INDEX 192


`define TIM7_CV_INDEX 224


`define TIM8_CV_INDEX 256


// Name:         TIM_INDIVIDUAL
// Default:      0
// Values:       -2147483648, ..., 2147483647
// 
// Individual Timer Interrupts used
`define TIM_INDIVIDUAL 0


// Name:         TIM_COMBINED
// Default:      1
// Values:       -2147483648, ..., 2147483647
// 
// Combined (Single) Timer Interrupt used
`define TIM_COMBINED 1


// `define TIMERS_ENCRYPT


// Name:         TIM_VERSION_ID
// Default:      0x3230352a
// Values:       0x0, ..., 0xffffffff
// 
// Each corekit has a version number. 
// This is relected in the ascii version number which needs to get translated. 
// 0 => 48 -> 30 
// 1 => 49 -> 31 
// 2 => 50 -> 32 
// A => 65 -> 41 
// B => 66 -> 42 
// C => 67 -> 43 
//  
// Current Version is 2.02* => 32_30_32_2A
`define TIM_VERSION_ID 32'h3230352a
