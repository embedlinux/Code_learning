bind CPU checker_CPU ck_CPU (clock,reset,CH,bus_mode,carry_mode,S1,ALU,IXR,IDB,PC,IR,TDB,C0,C1,C5,C6,mux_sel,PC_load);

module checker_CPU (
  input clock, 
  input reset,
  input logic [4:0] CH,
  input logic [2:0] bus_mode,
  input logic       carry_mode,
  input logic       S1,
  input logic [7:0]       ALU, 
  input logic [7:0]       IXR,
  input logic [7:0]       IDB, 
  input logic [7:0]       PC,
  input logic [1:0] IR,
  input logic [7:0]       TDB,
  input logic       C0, C1, C5, C6,
  input logic [2:0] mux_sel,
  input logic PC_load
);

`define INCA 2

// Example of $past system function
sequence e_l;
   @(posedge clock) (bus_mode == `INCA) && PC_load;
endsequence

sequence e_r;
   @(posedge clock) (`TRUE) ##[1:2] ((ALU == $past(ALU) + 1));
endsequence

property p_INC;
   @(posedge clock) e_l |=> ##[0:3] e_r;
endproperty

ae_INC: assert property (@(posedge clock) e_l |-> e_r);
ap_INC: assert property (p_INC);

// Example of local var
sequence e_l2;
   @(posedge clock) (bus_mode == `INCA);
endsequence

sequence e_r2;
   logic [7:0] ALU_prev;
   @(posedge clock) (PC_load, ALU_prev = ALU) ##[1:2] (ALU == ALU_prev + 1);
endsequence

sequence e_r3;
   logic [7:0] ALU_prev; // init to X
   bit [7:0] flag;       // init to 0 for 2-state
   @(posedge clock) (PC_load, ALU_prev = ALU) ##[1:2] (ALU == ALU_prev + 1, flag = 1);
endsequence

COVER_e_r3: cover property (@(posedge clock) e_r3); 

property e_INC2;
   @(posedge clock) e_l2 |-> e_r2;
endproperty

INCPC2: assert property (e_INC2);

property e_PCLD;
   int cnt;
   @(posedge clock) (`TRUE, cnt = 0)
                    ##0 
                    (PC_load, cnt = cnt + 1)[*5]
                    ##1
                    (cnt == 5);
endproperty

LD: assert property (e_PCLD);

property rich1;
  int var1;
  int var2;
  @(posedge clock) (`TRUE, var1= IXR, var2=IDB) ##0
  ($countones(var1)>=2, var1=var1+1)[*2] |=> ##[1:4] var2 == IDB && var1 == $countones(IXR);   
endproperty
Rich1: assert property(@(posedge clock) rich1);

endmodule
