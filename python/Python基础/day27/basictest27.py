#!/usr/bin/env python
# -*- coding:utf-8 -*-

# Author:
# @Time    :2019/7/24  20:55

# 1.面向对象多继承
# a. 先找左再找右
# class A(object):
#     pass
# class B(object):
#     def f1(self):
#         print('B')
# class C(A,B):
#     pass
# obj = C()
# obj.f1()
# b.经典类和新式类
# py2:经典类
#   新式类，如果自己或自己的前辈只要有人继承object，那么此类就是新式类。
# py3:新式类
#   经典类和新式类的查找成员的顺序不一样。
#   经典类，一条道走到黑（深度优先）。
#   新式类，C3算法实现（python2.3更新时c3算法）。
#
# Foo + (C, D, F, G) + (G, D, G, W) + (I, G, D, G, W)
#
# Foo, I, B,
# 获取第一个表头和其他表位进行比较不存在则拿走。
# 如果存在，则放弃，然后获取第二个表的表头再次和其他表的表尾进行比较。
#
# 经典类，一条道走到黑（深度优先）。
# 新式类，留个根。（科学C3算法）
#
# 注意事项：
#   super是遵循__mro__执行顺序。

# 2.网络基础
#     C/S架构:
#     B/S架构:
# 基于socket模块实现网络通信
# 为什么要网络通信发送的是字节？而不是字符串？
#     py3, send/recv 都是字节
#     py2, send/recv 都是字符串

# 服务端：
#     accept，阻塞：等待客户端来连接。
#     recv，  阻塞：等待客户端发来数据。
# 创建socket对象
# 绑定IP和端口
# 指定监听端口数量
# 等待客户端连接
# 获取消息(可指定接收字节大小)
# 给客户端回复消息
# 断开连接

# 客户端：
#     connect，阻塞：一直在连接，直到连接成功才往下运行其他代码。
# 创建socket对象
# 简介服务端,指定IP和端口

# 3.编写网络相关的程序
# import socket

'''
作业：
1.用户登录作业：
    1.服务端
        - 等待客户端来发送数据：用户名、密码
        - 本地文件中查看用户名密码是否合法。
        - 合法：登录成功
        - 否则：用户名或密码错误
    2.
        客户端
            - 用户输入：用户名、密码
            - 发送到服务端进行校验。

2.聊天工具(10086)
    1.服务端
        - 接收客户端发送的信息。
        - 检查是否有某些指定关键字。
        - 回复xx消息
        - 回复xx消息
        - 回复xx消息
        - 回复xx消息
    2.客户端
        - 持续
        - 问答
        - 关闭
'''

if __name__ == "__main__":
    pass
