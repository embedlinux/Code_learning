{\rtf1\ansi\ansicpg936\uc2 \deff0\deflang1033\deflangfe2052{\fonttbl{\f0\froman\fcharset0\fprq2{\*\panose 02020603050405020304}Times New Roman;}{\f1\fswiss\fcharset0\fprq2{\*\panose 020b0604020202020204}Arial;}
{\f2\fmodern\fcharset0\fprq1{\*\panose 02070309020205020404}Courier New;}{\f17\fnil\fcharset134\fprq2{\*\panose 02010600030101010101}\'cb\'ce\'cc\'e5{\*\falt SimSun};}
{\f21\fnil\fcharset134\fprq2{\*\panose 02010600030101010101}\'ba\'da\'cc\'e5{\*\falt SimHei};}{\f27\fnil\fcharset134\fprq2{\*\panose 02010600030101010101}@\'cb\'ce\'cc\'e5;}{\f28\fnil\fcharset134\fprq2{\*\panose 02010600030101010101}@\'ba\'da\'cc\'e5;}
{\f29\fmodern\fcharset134\fprq1{\*\panose 02010609030101010101}\'bf\'ac\'cc\'e5_GB2312;}{\f30\fmodern\fcharset134\fprq1{\*\panose 02010609030101010101}@\'bf\'ac\'cc\'e5_GB2312;}{\f91\froman\fcharset238\fprq2 Times New Roman CE;}
{\f92\froman\fcharset204\fprq2 Times New Roman Cyr;}{\f94\froman\fcharset161\fprq2 Times New Roman Greek;}{\f95\froman\fcharset162\fprq2 Times New Roman Tur;}{\f96\froman\fcharset177\fprq2 Times New Roman (Hebrew);}
{\f97\froman\fcharset178\fprq2 Times New Roman (Arabic);}{\f98\froman\fcharset186\fprq2 Times New Roman Baltic;}{\f99\fswiss\fcharset238\fprq2 Arial CE;}{\f100\fswiss\fcharset204\fprq2 Arial Cyr;}{\f102\fswiss\fcharset161\fprq2 Arial Greek;}
{\f103\fswiss\fcharset162\fprq2 Arial Tur;}{\f104\fswiss\fcharset177\fprq2 Arial (Hebrew);}{\f105\fswiss\fcharset178\fprq2 Arial (Arabic);}{\f106\fswiss\fcharset186\fprq2 Arial Baltic;}{\f107\fmodern\fcharset238\fprq1 Courier New CE;}
{\f108\fmodern\fcharset204\fprq1 Courier New Cyr;}{\f110\fmodern\fcharset161\fprq1 Courier New Greek;}{\f111\fmodern\fcharset162\fprq1 Courier New Tur;}{\f112\fmodern\fcharset177\fprq1 Courier New (Hebrew);}
{\f113\fmodern\fcharset178\fprq1 Courier New (Arabic);}{\f114\fmodern\fcharset186\fprq1 Courier New Baltic;}{\f229\fnil\fcharset0\fprq2 SimSun Western{\*\falt SimSun};}{\f309\fnil\fcharset0\fprq2 @\'cb\'ce\'cc\'e5 Western;}}{\colortbl;\red0\green0\blue0;
\red0\green0\blue255;\red0\green255\blue255;\red0\green255\blue0;\red255\green0\blue255;\red255\green0\blue0;\red255\green255\blue0;\red255\green255\blue255;\red0\green0\blue128;\red0\green128\blue128;\red0\green128\blue0;\red128\green0\blue128;
\red128\green0\blue0;\red128\green128\blue0;\red128\green128\blue128;\red192\green192\blue192;}{\stylesheet{\qj \li0\ri0\nowidctlpar\aspalpha\aspnum\faroman\rin0\lin0\itap0 
\fs21\lang1033\langfe2052\kerning2\loch\f0\hich\af0\dbch\af17\cgrid\langnp1033\langfenp2052 \snext0 Normal;}{\*\cs10 \additive Default Paragraph Font;}{\s15\qj \fi-5400\li5940\ri0\nowidctlpar\aspalpha\aspnum\faroman\rin0\lin5940\itap0 
\fs24\lang1033\langfe2052\kerning2\loch\f0\hich\af0\dbch\af17\cgrid\langnp1033\langfenp2052 \sbasedon0 \snext15 Body Text 2;}{\s16\qj \fi-3780\li5940\ri0\nowidctlpar\aspalpha\aspnum\faroman\rin0\lin5940\itap0 
\fs24\lang1033\langfe2052\kerning2\loch\f0\hich\af0\dbch\af17\cgrid\langnp1033\langfenp2052 \sbasedon0 \snext16 Body Text Indent 2;}{\s17\qj \li0\ri0\nowidctlpar\aspalpha\aspnum\faroman\rin0\lin0\itap0 \cbpat9 
\fs21\lang1033\langfe2052\kerning2\loch\f0\hich\af0\dbch\af17\cgrid\langnp1033\langfenp2052 \sbasedon0 \snext17 Document Map;}{\s18\qj \fi-2340\li3960\ri0\nowidctlpar\aspalpha\aspnum\faroman\rin0\lin3960\itap0 
\fs21\lang1033\langfe2052\kerning2\loch\f17\hich\af0\dbch\af17\cgrid\langnp1033\langfenp2052 \sbasedon0 \snext18 Body Text Indent 3;}{\s19\qc \li0\ri0\nowidctlpar\brdrb\brdrs\brdrw15\brsp20 \tqc\tx4153\tqr\tx8306\aspalpha\aspnum\faroman\rin0\lin0\itap0 
\fs18\lang1033\langfe2052\kerning2\loch\f0\hich\af0\dbch\af17\cgrid\langnp1033\langfenp2052 \sbasedon0 \snext19 header;}{\s20\ql \li0\ri0\nowidctlpar\tqc\tx4153\tqr\tx8306\aspalpha\aspnum\faroman\rin0\lin0\itap0 
\fs18\lang1033\langfe2052\kerning2\loch\f0\hich\af0\dbch\af17\cgrid\langnp1033\langfenp2052 \sbasedon0 \snext20 footer;}{\*\cs21 \additive \sbasedon10 page number;}{\s22\ql \li0\ri0\sb120\sa120\nowidctlpar\aspalpha\aspnum\faroman\rin0\lin0\itap0 
\b\caps\fs20\lang1033\langfe2052\kerning2\loch\f0\hich\af0\dbch\af17\cgrid\langnp1033\langfenp2052 \sbasedon0 \snext0 \sautoupd toc 1;}{\s23\ql \li210\ri0\nowidctlpar\aspalpha\aspnum\faroman\rin0\lin210\itap0 
\scaps\fs20\lang1033\langfe2052\kerning2\loch\f0\hich\af0\dbch\af17\cgrid\langnp1033\langfenp2052 \sbasedon0 \snext0 \sautoupd toc 2;}{\s24\ql \li420\ri0\nowidctlpar\aspalpha\aspnum\faroman\rin0\lin420\itap0 
\i\fs20\lang1033\langfe2052\kerning2\loch\f0\hich\af0\dbch\af17\cgrid\langnp1033\langfenp2052 \sbasedon0 \snext0 \sautoupd toc 3;}{\s25\ql \li630\ri0\nowidctlpar\aspalpha\aspnum\faroman\rin0\lin630\itap0 
\fs18\lang1033\langfe2052\kerning2\loch\f0\hich\af0\dbch\af17\cgrid\langnp1033\langfenp2052 \sbasedon0 \snext0 \sautoupd toc 4;}{\s26\ql \li840\ri0\nowidctlpar\aspalpha\aspnum\faroman\rin0\lin840\itap0 
\fs18\lang1033\langfe2052\kerning2\loch\f0\hich\af0\dbch\af17\cgrid\langnp1033\langfenp2052 \sbasedon0 \snext0 \sautoupd toc 5;}{\s27\ql \li1050\ri0\nowidctlpar\aspalpha\aspnum\faroman\rin0\lin1050\itap0 
\fs18\lang1033\langfe2052\kerning2\loch\f0\hich\af0\dbch\af17\cgrid\langnp1033\langfenp2052 \sbasedon0 \snext0 \sautoupd toc 6;}{\s28\ql \li1260\ri0\nowidctlpar\aspalpha\aspnum\faroman\rin0\lin1260\itap0 
\fs18\lang1033\langfe2052\kerning2\loch\f0\hich\af0\dbch\af17\cgrid\langnp1033\langfenp2052 \sbasedon0 \snext0 \sautoupd toc 7;}{\s29\ql \li1470\ri0\nowidctlpar\aspalpha\aspnum\faroman\rin0\lin1470\itap0 
\fs18\lang1033\langfe2052\kerning2\loch\f0\hich\af0\dbch\af17\cgrid\langnp1033\langfenp2052 \sbasedon0 \snext0 \sautoupd toc 8;}{\s30\ql \li1680\ri0\nowidctlpar\aspalpha\aspnum\faroman\rin0\lin1680\itap0 
\fs18\lang1033\langfe2052\kerning2\loch\f0\hich\af0\dbch\af17\cgrid\langnp1033\langfenp2052 \sbasedon0 \snext0 \sautoupd toc 9;}{\s31\qj \li0\ri0\nowidctlpar\aspalpha\aspnum\faroman\rin0\lin0\itap0 
\fs21\lang1033\langfe2052\kerning2\loch\f17\hich\af2\dbch\af17\cgrid\langnp1033\langfenp2052 \sbasedon0 \snext31 Plain Text;}}{\*\listtable{\list\listtemplateid24773816\listsimple{\listlevel\levelnfc0\levelnfcn0\leveljc0\leveljcn0\levelfollow0
\levelstartat1\levelspace0\levelindent0{\leveltext\'02\'00);}{\levelnumbers\'01;}\b0\i0\fs21\loch\af17\dbch\af17\chbrdr\brdrnone\brdrcf1 \chshdng0\chcfpat1\chcbpat1\fbias1 \fi-425\li425\jclisttab\tx425 }{\listname ;}\listid589318873}}{\*\listoverridetable
{\listoverride\listid589318873\listoverridecount0\ls1}}{\*\revtbl {Unknown;}}{\info{\title Module I8251A(dbus,rcd,gnd,txc_,write_,chipsel_,comdat_,read_,rxrdy,txrdysyndet,cts_,txe,txd,clk,reset,dsr_,rts_,dtr_,rxc_,vcc}{\author xyw}{\operator xyw}
{\creatim\yr1997\mo12\dy23\hr9\min19}{\revtim\yr2004\mo8\dy27\hr11\min25}{\printim\yr1998\mo3\dy19\hr18\min14}{\version116}{\edmins1218}{\nofpages50}{\nofwords8678}{\nofchars-32766}{\*\company buaa}{\nofcharsws0}{\vern8249}}
\paperw11906\paperh16838\margl1797\margr1797\margt1157\margb1440\gutter0 \deftab425\ftnbj\aenddoc\pgnstart0\hyphcaps0\formshade\horzdoc\dgmargin\dghspace105\dgvspace156\dghorigin1797\dgvorigin1157\dghshow0\dgvshow2\jcompress\lnongrid
\viewkind1\viewscale100 {\*\fchars 
!),.:\'3b?]\'7d\'a1\'a7\'a1\'a4\'a1\'a6\'a1\'a5\'a8\'44\'a1\'ac\'a1\'af\'a1\'b1\'a1\'ad\'a1\'c3\'a1\'a2\'a1\'a3\'a1\'a8\'a1\'a9\'a1\'b5\'a1\'b7\'a1\'b9\'a1\'bb\'a1\'bf\'a1\'b3\'a1\'bd\'a3\'a1\'a3\'a2\'a3\'a7\'a3\'a9\'a3\'ac\'a3\'ae\'a3\'ba\'a3\'bb
\'a3\'bf\'a3\'dd\'a3\'e0\'a3\'fc\'a3\'fd\'a1\'ab\'a1\'e9}{\*\lchars ([\'7b\'a1\'a4\'a1\'ae\'a1\'b0\'a1\'b4\'a1\'b6\'a1\'b8\'a1\'ba\'a1\'be\'a1\'b2\'a1\'bc\'a3\'a8\'a3\'ae\'a3\'db\'a3\'fb\'a1\'ea\'a3\'a4}\fet0\sectd 
\psz9\pgnrestart\pgnstarts0\linex0\headery851\footery992\colsx425\endnhere\pgnhn1\sectlinegrid312\sectspecifyl {\header \pard\plain \s19\qr \li0\ri360\nowidctlpar\brdrb\brdrs\brdrw15 \tqc\tx4153\tqr\tx8306\aspalpha\aspnum\faroman\rin360\lin0\itap0 
\fs18\lang1033\langfe2052\kerning2\loch\af0\hich\af0\dbch\af17\cgrid\langnp1033\langfenp2052 {\v\loch\af21\hich\af1\dbch\af21 \hich\af1\dbch\af21\loch\f21  }{\loch\af21\dbch\af21 
\par }}{\footer \pard\plain \s20\ql \li0\ri0\nowidctlpar\tqc\tx4153\tqr\tx8306\pvpara\phmrg\posxr\posy0\aspalpha\aspnum\faroman\rin0\lin0\itap0 \fs18\lang1033\langfe2052\kerning2\loch\af0\hich\af0\dbch\af17\cgrid\langnp1033\langfenp2052 {\field{\*\fldinst {
\cs21 \hich\af0\dbch\af17\loch\f0 PAGE  }}{\fldrslt {\cs21\lang1024\langfe1024\noproof \hich\af0\dbch\af17\loch\f0 0}}}{\cs21 
\par }\pard \s20\ql \li0\ri360\nowidctlpar\tqc\tx4153\tqr\tx8306\aspalpha\aspnum\faroman\rin360\lin0\itap0 {
\par }}{\*\pnseclvl1\pnucrm\pnstart1\pnindent720\pnhang{\pntxta \dbch .}}{\*\pnseclvl2\pnucltr\pnstart1\pnindent720\pnhang{\pntxta \dbch .}}{\*\pnseclvl3\pndec\pnstart1\pnindent720\pnhang{\pntxta \dbch .}}{\*\pnseclvl4\pnlcltr\pnstart1\pnindent720\pnhang
{\pntxta \dbch )}}{\*\pnseclvl5\pndec\pnstart1\pnindent720\pnhang{\pntxtb \dbch (}{\pntxta \dbch )}}{\*\pnseclvl6\pnlcltr\pnstart1\pnindent720\pnhang{\pntxtb \dbch (}{\pntxta \dbch )}}{\*\pnseclvl7\pnlcrm\pnstart1\pnindent720\pnhang{\pntxtb \dbch (}
{\pntxta \dbch )}}{\*\pnseclvl8\pnlcltr\pnstart1\pnindent720\pnhang{\pntxtb \dbch (}{\pntxta \dbch )}}{\*\pnseclvl9\pnlcrm\pnstart1\pnindent720\pnhang{\pntxtb \dbch (}{\pntxta \dbch )}}\pard\plain \qc \li0\ri0\nowidctlpar\faroman\rin0\lin0\itap0 
\fs21\lang1033\langfe2052\kerning2\loch\af0\hich\af0\dbch\af17\cgrid\langnp1033\langfenp2052 {\b\fs32\dbch\af21 \loch\af0\hich\af0\dbch\f21 \'b5\'da\'ca\'ae\'b0\'cb\'d5\'c2}{\b\fs32\dbch\af21 \hich\af0\dbch\af21\loch\f0  }{\b\fs32\dbch\af21 
\loch\af0\hich\af0\dbch\f21 \'c0\'fd\'cc\'e2}{
\par }\pard \qj \li0\ri0\nowidctlpar\aspalpha\aspnum\faroman\rin0\lin0\itap0 {\hich\af0\dbch\af17\loch\f0  
\par }{\b \hich\af0\dbch\af17\loch\f0 //[}{\b \loch\af0\hich\af0\dbch\f17 \'c0\'fd}{\b \hich\af0\dbch\af17\loch\f0 1]. }{\b \loch\af0\hich\af0\dbch\f17 \'c4\'a3\'ca\'fd\'d7\'aa\'bb\'bb\'c6\'f7}{\b \hich\af0\dbch\af17\loch\f0 AD7886}{\b 
\loch\af0\hich\af0\dbch\f17 \'b7\'c2\'d5\'e6\'c4\'a3\'d0\'cd\'a3\'a8\'d0\'e9\'c4\'e2\'c4\'a3\'bf\'e9\'a3\'a9\'b5\'c4\'c9\'e8\'bc\'c6\'a3\'ba}{
\par \hich\af0\dbch\af17\loch\f0 //+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
\par \hich\af0\dbch\af17\loch\f0 `timescale 100ps/100ps      //}{\loch\af0\hich\af0\dbch\f17 \'b6\'a8\'d2\'e5\'ca\'b1\'bc\'e4\'b5\'a5\'ce\'bb\'ba\'cd\'ca\'b1\'bc\'e4\'b7\'d6\'b1\'e7\'b6\'c8}{
\par }\pard\plain \s31\qj \li0\ri0\nowidctlpar\aspalpha\aspnum\faroman\rin0\lin0\itap0 \fs21\lang1033\langfe2052\kerning2\loch\af17\hich\af2\dbch\af17\cgrid\langnp1033\langfenp2052 {\f0 \hich\af0\dbch\af17\loch\f0 module   adc (nconvst, nbusy, data);  
\par \hich\af0\dbch\af17\loch\f0 input\tab   nconvst;         // A/D }{\f0 \loch\af0\hich\af0\dbch\f17 \'c6\'f4\'b6\'af\'c2\'f6\'b3\'e5}{\f0 \hich\af0\dbch\af17\loch\f0 ST}{\f0 \loch\af0\hich\af0\dbch\f17 \'a3\'ac\loch\af0\hich\af0\dbch\f17 \'bc\'b4\'c9\'cf
\'cd\'bc\'d6\'d0}{\f0 \hich\af0\dbch\af17\loch\f0  
\par \hich\af0\dbch\af17\loch\f0 output    nbusy;       // A/D }{\f0 \loch\af0\hich\af0\dbch\f17 \'b9\'a4\'d7\'f7\'b1\'ea\'d6\'be\loch\af0\hich\af0\dbch\f17 \'a3\'ac\loch\af0\hich\af0\dbch\f17 \'bc\'b4\'c9\'cf\'cd\'bc\'d6\'d0}{\f0 \hich\af0\dbch\af17\loch\f0  

\par \hich\af0\dbch\af17\loch\f0 output       data;         // }{\f0 \loch\af0\hich\af0\dbch\f17 \'ca\'fd\'be\'dd\'d7\'dc\'cf\'df\loch\af0\hich\af0\dbch\f17 \'a3\'ac\loch\af0\hich\af0\dbch\f17 \'b4\'d3}{\f0 \hich\af0\dbch\af17\loch\f0 AD.DATA}{\f0 
\loch\af0\hich\af0\dbch\f17 \'ce\'c4\'bc\'fe\'d6\'d0\'b6\'c1\'c8\'a1\'ca\'fd\'be\'dd\'ba\'f3\'be\'ad\'b6\'cb\'bf\'da\'ca\'e4\'b3\'f6}{\f0 
\par \hich\af0\dbch\af17\loch\f0 reg[7:0]  databuf,i;   // }{\f0 \loch\af0\hich\af0\dbch\f17 \'c4\'da\'b2\'bf\'bc\'c4\'b4\'e6\'c6\'f7}{\f0 
\par \hich\af0\dbch\af17\loch\f0 reg       nbusy;
\par \hich\af0\dbch\af17\loch\f0 wire[7:0] data;
\par \hich\af0\dbch\af17\loch\f0 reg[7:0]  data_mem[0:255];
\par \hich\af0\dbch\af17\loch\f0 reg       link_bus;
\par \hich\af0\dbch\af17\loch\f0 integer   tconv,
\par \hich\af0\dbch\af17\loch\f0           t5,
\par \hich\af0\dbch\af17\loch\f0           t8,
\par \hich\af0\dbch\af17\loch\f0           t9,
\par \hich\af0\dbch\af17\loch\f0           t12;
\par \hich\af0\dbch\af17\loch\f0 in\hich\af0\dbch\af17\loch\f0 teger   wideth1,
\par \hich\af0\dbch\af17\loch\f0           wideth2,
\par \hich\af0\dbch\af17\loch\f0           wideth;          
\par \hich\af0\dbch\af17\loch\f0 //}{\f0 \loch\af0\hich\af0\dbch\f17 \'ca\'b1\'bc\'e4\'b2\'ce\'ca\'fd\'b6\'a8\'d2\'e5}{\f0 \hich\af0\dbch\af17\loch\f0 (}{\f0 \loch\af0\hich\af0\dbch\f17 \'d2\'c0\'be\'dd}{\f0 \hich\af0\dbch\af17\loch\f0 AD7886}{\f0 
\loch\af0\hich\af0\dbch\f17 \'ca\'d6\'b2\'e1}{\f0 \hich\af0\dbch\af17\loch\f0 )}{\f0 \loch\af0\hich\af0\dbch\f17 \'a3\'ba}{\f0 
\par \hich\af0\dbch\af17\loch\f0 always @(negedge nconvst)
\par \hich\af0\dbch\af17\loch\f0    begin
\par \hich\af0\dbch\af17\loch\f0          tconv =9500+\{$random\}%500; //(type 950ns, max 1000ns}{\f0 \loch\af0\hich\af0\dbch\f17 \'a3\'a9}{\f0 \hich\af0\dbch\af17\loch\f0 Conversion Time
\par \hich\af0\dbch\af17\loch\f0          t5 =\{$random\}\hich\af0\dbch\af17\loch\f0 %1000;  //(max 100ns)   CONVST to BUSY Propagation Dlay
\par \hich\af0\dbch\af17\loch\f0                              // CL = 10pf
\par \hich\af0\dbch\af17\loch\f0          t8 = 200;     //(min 20)  CL=20pf  Data Setup Time Prior to BUSY
\par \hich\af0\dbch\af17\loch\f0                       //(min 10)  CL=100pf
\par \hich\af0\dbch\af17\loch\f0          t9 = 100+\{$random\}%900; //(min 1\hich\af0\dbch\af17\loch\f0 0ns, max 100ns) Bus Relinquish Time After       
\par \hich\af0\dbch\af17\loch\f0                                  //CONVST
\par \hich\af0\dbch\af17\loch\f0          t12 = 2500;   //(type) BUSY High to CONVST Low, SHA Acquisition Time
\par \hich\af0\dbch\af17\loch\f0    end
\par 
\par \hich\af0\dbch\af17\loch\f0 initial
\par \hich\af0\dbch\af17\loch\f0       begin 
\par \tab \hich\af0\dbch\af17\loch\f0    $readmemh("adc.data",data_mem);  //}{\f0 \loch\af0\hich\af0\dbch\f17 \'b4\'d3\'ca\'fd\'be\'dd\'ce\'c4\'bc\'fe}{\f0 \hich\af0\dbch\af17\loch\f0 adc.data}{\f0 \loch\af0\hich\af0\dbch\f17 \'d6\'d0\'b6\'c1\'c8\'a1\'ca\'fd
\'be\'dd}{\f0 \hich\af0\dbch\af17\loch\f0  \hich\af0\dbch\af17\loch\f0    
\par \tab \hich\af0\dbch\af17\loch\f0    i = 0;
\par \tab \hich\af0\dbch\af17\loch\f0    nbusy  = 1; 
\par \hich\af0\dbch\af17\loch\f0            link_bus = 0;
\par \hich\af0\dbch\af17\loch\f0       end 
\par 
\par \hich\af0\dbch\af17\loch\f0 assign data = link_bus? databuf:8'bzz; //}{\f0 \loch\af0\hich\af0\dbch\f17 \'c8\'fd\'cc\'ac\'d7\'dc\'cf\'df}{\f0 
\par 
\par \hich\af0\dbch\af17\loch\f0 /*----------------------------------------------------------------------------
\par }{\f0 \loch\af0\hich\af0\dbch\f17 \'d4\'da\'d0\'c5\'ba\'c5}{\f0 \hich\af0\dbch\af17\loch\f0 nconvst}{\f0 \loch\af0\hich\af0\dbch\f17 \'b5\'c4\'b8\'ba\'cc\'f8\'bd\'b5\'d1\'d8\'b5\'bd\'c0\'b4\'ba\'f3\loch\af0\hich\af0\dbch\f17 \'a3\'ac
\loch\af0\hich\af0\dbch\f17 \'b8\'f4}{\f0 \hich\af0\dbch\af17\loch\f0 t5}{\f0 \loch\af0\hich\af0\dbch\f17 \'c3\'eb}{\f0 \hich\af0\dbch\af17\loch\f0 nbusy}{\f0 \loch\af0\hich\af0\dbch\f17 \'d0\'c5\'ba\'c5\'d6\'c3\'ce\'aa\'b5\'cd\loch\af0\hich\af0\dbch\f17 
\'a3\'ac}{\f0 \hich\af0\dbch\af17\loch\f0 tconv}{\f0 \loch\af0\hich\af0\dbch\f17 \'ca\'c7}{\f0 \hich\af0\dbch\af17\loch\f0 AD}{\f0 \loch\af0\hich\af0\dbch\f17 \'bd\'ab\'c4\'a3\'c4\'e2\'d0\'c5\'ba\'c5\'d7\'aa\'bb\'bb\'ce\'aa\'ca\'fd\'d7\'d6\'d0\'c5\'ba\'c5
\'b5\'c4\'ca\'b1\'bc\'e4\loch\af0\hich\af0\dbch\f17 \'a3\'ac\loch\af0\hich\af0\dbch\f17 \'d4\'da\'d0\'c5\'ba\'c5}{\f0 \hich\af0\dbch\af17\loch\f0 nconvst}{\f0 \loch\af0\hich\af0\dbch\f17 \'b5\'c4\'d5\'fd\'cc\'f8\'bd\'b5\'d1\'d8\'b5\'bd\'c0\'b4\'ba\'f3
\'be\'ad\'b9\'fd}{\f0 \hich\af0\dbch\af17\loch\f0 tconv}{\f0 \loch\af0\hich\af0\dbch\f17 \'ca\'b1\'bc\'e4\'ba\'f3\loch\af0\hich\af0\dbch\f17 \'a3\'ac\loch\af0\hich\af0\dbch\f17 \'ca\'e4\'b3\'f6}{\f0 \hich\af0\dbch\af17\loch\f0 nbusy}{\f0 
\loch\af0\hich\af0\dbch\f17 \'d0\'c5\'ba\'c5\'b1\'e4\'ce\'aa\'b8\'df\'a1\'a3}{\f0 \hich\af0\dbch\af17\loch\f0  
\par \hich\af0\dbch\af17\loch\f0 --------------------------------------*/  
\par \hich\af0\dbch\af17\loch\f0 always @(negedge nconvst) 
\par \tab \hich\af0\dbch\af17\loch\f0     fork
\par \tab \hich\af0\dbch\af17\loch\f0     \tab  #t5  nbusy =0;
\par \tab \hich\af0\dbch\af17\loch\f0        @(posedge nconvst)
\par \hich\af0\dbch\af17\loch\f0                   begin 
\par \hich\af0\dbch\af17\loch\f0                        #tconv  nbusy=1;
\par \hich\af0\dbch\af17\loch\f0                   \hich\af0\dbch\af17\loch\f0 end\tab \hich\af0\dbch\af17\loch\f0       
\par \tab \hich\af0\dbch\af17\loch\f0     join
\par \hich\af0\dbch\af17\loch\f0 /*------------------------------------------------------------------------\tab       
\par \hich\af0\dbch\af17\loch\f0 nconvst}{\f0 \loch\af0\hich\af0\dbch\f17 \'d0\'c5\'ba\'c5\'b5\'c4\'cf\'c2\'bd\'b5\'d1\'d8\'b4\'a5\'b7\'a2\'a3\'ac\'be\'ad\'b9\'fd}{\f0 \hich\af0\dbch\af17\loch\f0 t9 }{\f0 \loch\af0\hich\af0\dbch\f17 \'d1\'d3\'ca\'b1\'ba\'f3
\'a3\'ac\'b0\'d1\'ca\'fd\'be\'dd\'d7\'dc\'cf\'df\'ca\'e4\'b3\'f6\'b9\'d8\'b1\'d5\'d6\'c3\'ce\'aa\'b8\'df\'d7\'e8\'cc\'ac\'a3\'ac\'c8\'e7\'cd\'bc\'ca\'be\'a1\'a3}{\f0 
\par \hich\af0\dbch\af17\loch\f0  \hich\af0\dbch\af17\loch\f0 nconvst}{\f0 \loch\af0\hich\af0\dbch\f17 \'d0\'c5\'ba\'c5\'b5\'c4\'c9\'cf\'c9\'fd\'d1\'d8\'b5\'bd\'c0\'b4\'ba\'f3\'a3\'ac\'be\'ad\'b9\'fd\'a3\'a8}{\f0 \hich\af0\dbch\af17\loch\f0 tconv - t8)}{\f0 
\loch\af0\hich\af0\dbch\f17 \'ca\'b1\'bc\'e4\'a3\'ac\'ca\'e4\'b3\'f6\'d2\'bb\'b8\'f6\'d7\'d6\'bd\'da\'a3\'a8}{\f0 \hich\af0\dbch\af17\loch\f0 8}{\f0 \loch\af0\hich\af0\dbch\f17 \'ce\'bb\'ca\'fd\'be\'dd\'a3\'a9\'b5\'bd}{\f0 \hich\af0\dbch\af17\loch\f0 
databuf}{\f0 \loch\af0\hich\af0\dbch\f17 \'a3\'ac}{\f0 \hich\af0\dbch\af17\loch\f0  }{\f0 \loch\af0\hich\af0\dbch\f17 \'b8\'c3\'ca\'fd\'be\'dd\'c0\'b4\'d7\'d4\'d3\'da}{\f0 \hich\af0\dbch\af17\loch\f0 data_mem}{\f0 \loch\af0\hich\af0\dbch\f17 \'a1\'a3
\loch\af0\hich\af0\dbch\f17 \'b6\'f8}{\f0 \hich\af0\dbch\af17\loch\f0 data_mem}{\f0 \loch\af0\hich\af0\dbch\f17 \'d6\'d0\'b5\'c4\'ca\'fd\'be\'dd\'ca\'c7\'b3\'f5\'ca\'bc\'bb\'af\'ca\'b1\'b4\'d3\'ca\'fd\'be\'dd\'ce\'c4\'bc\'fe}{\f0 
\hich\af0\dbch\af17\loch\f0 AD.DATA}{\f0 \loch\af0\hich\af0\dbch\f17 \'d6\'d0\'b6\'c1\'c8\'a1\'b5\'c4\'a1\'a3}{\f0 \hich\af0\dbch\af17\loch\f0  }{\f0 \loch\af0\hich\af0\dbch\f17 \'b4\'cb\'ca\'b1\'d3\'a6\loch\af0\hich\af0\dbch\f17 \'c6\'f4\'b6\'af\'d7\'dc
\'cf\'df\'b5\'c4\'c8\'fd\'cc\'ac\'ca\'e4\'b3\'f6\'a1\'a3}{\f0 \hich\af0\dbch\af17\loch\f0  
\par \hich\af0\dbch\af17\loch\f0 ---------------------------------------------------------------------------*/
\par \hich\af0\dbch\af17\loch\f0 always @(negedge nconvst)          
\par \hich\af0\dbch\af17\loch\f0       begin
\par \hich\af0\dbch\af17\loch\f0          @(posedge nconvst)
\par \hich\af0\dbch\af17\loch\f0             begin 
\par \hich\af0\dbch\af17\loch\f0               #(tconv-t8)   databuf=data_mem[i];  
\par \hich\af0\dbch\af17\loch\f0             end
\par \hich\af0\dbch\af17\loch\f0     \hich\af0\dbch\af17\loch\f0         
\par \hich\af0\dbch\af17\loch\f0          if(wideth <10000  && wideth>500)  
\par \hich\af0\dbch\af17\loch\f0             begin
\par \hich\af0\dbch\af17\loch\f0               if(i==255) i=0;
\par \hich\af0\dbch\af17\loch\f0               else i=i+1;
\par \hich\af0\dbch\af17\loch\f0             end   
\par \hich\af0\dbch\af17\loch\f0          else  i = i;
\par \hich\af0\dbch\af17\loch\f0       \hich\af0\dbch\af17\loch\f0 end
\par \hich\af0\dbch\af17\loch\f0 //}{\f0 \loch\af0\hich\af0\dbch\f17 \'d4\'da\'c4\'a3\'ca\'fd\'d7\'aa\'bb\'bb\'c6\'da\'bc\'e4\'b9\'d8\'b1\'d5\'c8\'fd\'cc\'ac\'ca\'e4\'b3\'f6\'a3\'ac\'d7\'aa\'bb\'bb\'bd\'e1\'ca\'f8\'ca\'b1\'c6\'f4\'b6\'af\'c8\'fd\'cc\'ac
\'ca\'e4\'b3\'f6}{\f0 
\par \hich\af0\dbch\af17\loch\f0 always @(negedge nconvst)
\par \hich\af0\dbch\af17\loch\f0   fork
\par \hich\af0\dbch\af17\loch\f0        #t9 link_b\hich\af0\dbch\af17\loch\f0 us = 1'b0;    //}{\f0 \loch\af0\hich\af0\dbch\f17 \'b9\'d8\'b1\'d5\'c8\'fd\'cc\'ac\'ca\'e4\'b3\'f6\loch\af0\hich\af0\dbch\f17 \'a3\'ac\loch\af0\hich\af0\dbch\f17 \'b2\'bb\'d4\'ca
\'d0\'ed\'d7\'dc\'cf\'df\'ca\'e4\'b3\'f6}{\f0 
\par \hich\af0\dbch\af17\loch\f0        @(posedge nconvst)
\par \hich\af0\dbch\af17\loch\f0             begin 
\par \hich\af0\dbch\af17\loch\f0             #(tconv-t8)   link_bus=1'b1;     
\par \hich\af0\dbch\af17\loch\f0             end
\par \hich\af0\dbch\af17\loch\f0   join
\par \hich\af0\dbch\af17\loch\f0 /*------------------------------------------------------------------------
\par }{\f0 \loch\af0\hich\af0\dbch\f17 \'b5\'b1}{\f0 \hich\af0\dbch\af17\loch\f0 nconvst}{\f0 \loch\af0\hich\af0\dbch\f17 \'ca\'e4\'c8\'eb\'d0\'c5\'ba\'c5\'b5\'c4\'cf\'c2\'d2\'bb\'b8\'f6\'d7\'aa\'bb\'bb\'b5\'c4\'cf\'c2\'bd\'b5\'d1\'d8\'d3\'eb}{\f0 
\hich\af0\dbch\af17\loch\f0 nbusy}{\f0 \loch\af0\hich\af0\dbch\f17 \'d0\'c5\'ba\'c5\'c9\'cf\'c9\'fd\'d1\'d8\'d6\'ae\'bc\'e4\'ca\'b1\loch\af0\hich\af0\dbch\f17 \'bc\'e4\'d1\'d3\'b3\'d9\'d0\'a1\'d3\'da}{\f0 \hich\af0\dbch\af17\loch\f0 t12}{\f0 
\loch\af0\hich\af0\dbch\f17 \'ca\'b1\loch\af0\hich\af0\dbch\f17 \'a3\'ac}{\f0 
\par }{\f0 \loch\af0\hich\af0\dbch\f17 \'bd\'ab\'bb\'e1\'b3\'f6\'cf\'d6\'be\'af\'b8\'e6\'d0\'c5\'cf\'a2\'a3\'ac\'cd\'a8\'d6\'aa\'c9\'e8\'bc\'c6\'d5\'df\'c7\'eb\'c7\'f3\'d7\'aa\'bb\'bb\'b5\'c4\'ca\'e4\'c8\'eb\'d0\'c5\'ba\'c5\'c6\'b5\'c2\'ca\'cc\'ab\'bf\'ec
\'a3\'ac}{\f0 \hich\af0\dbch\af17\loch\f0 A/D}{\f0 \loch\af0\hich\af0\dbch\f17 \'c6\'f7\'bc\'fe\'d7\'aa\'bb\'bb\'cb\'d9\'b6\'c8\'b8\'fa\'b2\'bb\'c9\'cf\'a1\'a3}{\f0 
\par }{\f0 \loch\af0\hich\af0\dbch\f17 \'b7\'c2\'d5\'e6\'c4\'a3\'d0\'cd\'b2\'bb\'bd\'f6\'c4\'dc\'b9\'bb\'ca\'b5\'cf\'d6\'d3\'b2\'bc\'fe\'b5\'e7\'c2\'b7\'b5\'c4\'ca\'e4\'b3\'f6\'b9\'a6\'c4\'dc\'a3\'ac\'cd\'ac\'ca\'b1\'c4\'dc\'b9\'bb\'b6\'d4\'ca\'e4\'c8\'eb
\'d0\'c5\'ba\'c5\'bd\'f8\'d0\'d0\'bc\'ec\'b2\'e2\'a3\'ac}{\f0 
\par }{\f0 \loch\af0\hich\af0\dbch\f17 \'b5\'b1\'ca\'e4\'c8\'eb\'d0\'c5\'ba\'c5\'b2\'bb\'b7\'fb\'ba\'cf\'ca\'d6\'b2\'e1\'d2\'aa\'c7\'f3\'ca\'b1\'a3\'ac\'cf\'d4\'ca\'be\'be\'af\'b8\'e6\'d0\'c5\'cf\'a2\'a1\'a3}{\f0 
\par \hich\af0\dbch\af17\loch\f0 -------------------------------------------------------------------------*/
\par 
\par \hich\af0\dbch\af17\loch\f0 // }{\f0 \loch\af0\hich\af0\dbch\f17 \'bc\'ec\'b2\'e9}{\f0 \hich\af0\dbch\af17\loch\f0 A/D}{\f0 \loch\af0\hich\af0\dbch\f17 \'c6\'f4\'b6\'af\'d0\'c5\'ba\'c5\'b5\'c4\'c6\'b5\'c2\'ca\'ca\'c7\'b7\'f1\'cc\'ab\'bf\'ec}{\f0 
\par \hich\af0\dbch\af17\loch\f0      \hich\af0\dbch\af17\loch\f0 always @(posedge nbusy)
\par \hich\af0\dbch\af17\loch\f0        begin
\par \hich\af0\dbch\af17\loch\f0        \hich\af0\dbch\af17\loch\f0    #t12;
\par \hich\af0\dbch\af17\loch\f0           if (!nconvst) 
\par \hich\af0\dbch\af17\loch\f0              begin 
\par \hich\af0\dbch\af17\loch\f0                $display("Warning!  SHA Acquisition Time is too short!");
\par \hich\af0\dbch\af17\loch\f0              end
\par \hich\af0\dbch\af17\loch\f0         //  else  $display(" SHA Acquisition Time is enough! \hich\af0\dbch\af17\loch\f0 ");
\par \hich\af0\dbch\af17\loch\f0        end
\par \hich\af0\dbch\af17\loch\f0 // }{\f0 \loch\af0\hich\af0\dbch\f17 \'bc\'ec\'b2\'e9}{\f0 \hich\af0\dbch\af17\loch\f0 A/D}{\f0 \loch\af0\hich\af0\dbch\f17 \'c6\'f4\'b6\'af\'d0\'c5\'ba\'c5\'b5\'c4\'b8\'ba\'c2\'f6\'b3\'e5\'bf\'ed\'b6\'c8\'ca\'c7\'b7\'f1
\'d7\'e3\'b9\'bb\'ba\'cd\'cc\'ab\'bf\'ed}{\f0 
\par 
\par \hich\af0\dbch\af17\loch\f0    \hich\af0\dbch\af17\loch\f0 always\hich\af0\dbch\af17\loch\f0  @(negedge nconvst)
\par \hich\af0\dbch\af17\loch\f0      begin
\par \hich\af0\dbch\af17\loch\f0           wideth=$time;
\par \hich\af0\dbch\af17\loch\f0           @(posedge nconvst)  wideth=$time-wideth;
\par \hich\af0\dbch\af17\loch\f0           if (wideth<=500 || wideth > 10000)
\par \hich\af0\dbch\af17\loch\f0             begin
\par \hich\af0\dbch\af17\loch\f0              
\par \hich\af0\dbch\af17\loch\f0              $display("nCONVST Pulse Width = %d",wideth);
\par \hich\af0\dbch\af17\loch\f0              $display("Warning! nCONVST Pulse Width is too narrow or too wide!");
\par \hich\af0\dbch\af17\loch\f0              //$stop;
\par \hich\af0\dbch\af17\loch\f0             end
\par \hich\af0\dbch\af17\loch\f0     end
\par 
\par \hich\af0\dbch\af17\loch\f0 endmodule
\par }\pard\plain \qj \li0\ri0\nowidctlpar\aspalpha\aspnum\faroman\rin0\lin0\itap0 \fs21\lang1033\langfe2052\kerning2\loch\af0\hich\af0\dbch\af17\cgrid\langnp1033\langfenp2052 {
\par \hich\af0\dbch\af17\loch\f0 //+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
\par \hich\af0\dbch\af17\loch\f0  
\par }{\b 
\par \hich\af0\dbch\af17\loch\f0 //[}{\b \loch\af0\hich\af0\dbch\f17 \'c0\'fd}{\b \hich\af0\dbch\af17\loch\f0 1].}{\b \loch\af0\hich\af0\dbch\f17 \'a1\'b0\loch\af0\hich\af0\dbch\f17 \'c9\'cc\'d2\'b5\'bb\'af\loch\af0\hich\af0\dbch\f17 \'a1\'b1
\loch\af0\hich\af0\dbch\f17 \'b5\'c4\'d0\'e9\'c4\'e2\'c4\'a3\'bf\'e9\'d6\'ae\'d2\'bb\loch\af0\hich\af0\dbch\f17 \'a3\'ba}{\b \hich\af0\dbch\af17\loch\f0 Intel USART 825\hich\af0\dbch\af17\loch\f0 1A (}{\b \loch\af0\hich\af0\dbch\f17 \'cd\'a8\'d3\'c3
\'b4\'ae\'d0\'d0\'d2\'ec\'b2\'bd\'ca\'d5\'b7\'a2\'c6\'f7\'d0\'be\'c6\'ac}{\b \hich\af0\dbch\af17\loch\f0 ) }{
\par \hich\af0\dbch\af17\loch\f0 /****************************************************************************
\par \hich\af0\dbch\af17\loch\f0 CADENCE DESIGN SYSTEMS, Inc. does not guarantee the accuracy or completeness of 
\par \hich\af0\dbch\af17\loch\f0 this model. Anyone who using this does so at their own risk.
\par \hich\af0\dbch\af17\loch\f0 ******************\hich\af0\dbch\af17\loch\f0 ***********************************************************/
\par \hich\af0\dbch\af17\loch\f0  
\par \hich\af0\dbch\af17\loch\f0 /*****************************************************************************
\par }\pard \qc \li0\ri0\nowidctlpar\aspalpha\aspnum\faroman\outlinelevel0\rin0\lin0\itap0 {\b \loch\af0\hich\af0\dbch\f17 \'cd\'a8\'d3\'c3\'b4\'ae\'d0\'d0\'d2\'ec\'b2\'bd\'ca\'d5\'b7\'a2\'c6\'f7}{\b \hich\af0\dbch\af17\loch\f0 8251}{\b 
\loch\af0\hich\af0\dbch\f17 \'b5\'c4}{\b \hich\af0\dbch\af17\loch\f0 Verilog HDL}{\b \loch\af0\hich\af0\dbch\f17 \'d4\'b4\'b4\'fa\'c2\'eb}{\b 
\par }\pard \qc \li0\ri0\nowidctlpar\aspalpha\aspnum\faroman\rin0\lin0\itap0 {\fs18\dbch\af29 \loch\af0\hich\af0\dbch\f29 \'d7\'a2\'d2\'e2\'a3\'ba\'d7\'f7\'d5\'df\'b2\'bb\'c4\'dc\'b1\'a3\'d6\'a4\'b1\'be\'c4\'a3\'bf\'e9\'b5\'c4\'cd\'ea\'d5\'fb\'ba\'cd\'be\'ab
\'c8\'b7\'a3\'ac\'ca\'b9\'d3\'c3\'b1\'be\'c4\'a3\'bf\'e9\'d5\'df\'c8\'e7\'d3\'f6\'ce\'ca\'cc\'e2\'d2\'bb\'c7\'d0\'d4\'f0\'c8\'ce\'d7\'d4\'b8\'ba}{\fs18\dbch\af29 
\par }\pard \qj \li0\ri0\nowidctlpar\aspalpha\aspnum\faroman\rin0\lin0\itap0 {\dbch\af29 \hich\af0\dbch\af29\loch\f0 ******************************************************************************/
\par }\pard\plain \s31\qj \li0\ri0\nowidctlpar\aspalpha\aspnum\faroman\rin0\lin0\itap0 \fs21\lang1033\langfe2052\kerning2\loch\af17\hich\af2\dbch\af17\cgrid\langnp1033\langfenp2052 {\f0 
\par \hich\af0\dbch\af17\loch\f0 module I8251A ( dbus, rcd, gnd, txc_, write_, chipsel_, comdat_,  
\par }\pard \s31\qj \li1700\ri0\nowidctlpar\aspalpha\aspnum\faroman\rin0\lin1700\itap0 {\f0 \hich\af0\dbch\af17\loch\f0        read_, rxrdy, txrdy, syndet, cts_, txe, txd,  
\par \hich\af0\dbch\af17\loch\f0                   clk, reset, dsr_,rts_,dtr_,rxc_,vcc)\hich\af0\dbch\af17\loch\f0 ; 
\par }\pard \s31\qj \li0\ri0\nowidctlpar\aspalpha\aspnum\faroman\rin0\lin0\itap0 {\f0 \hich\af0\dbch\af17\loch\f0   
\par \hich\af0\dbch\af17\loch\f0 /* timing constants ,for A. C. timing check, only non-zero times are  
\par \hich\af0\dbch\af17\loch\f0 specified,in nano-sec  */ 
\par \hich\af0\dbch\af17\loch\f0 /*  read cycle */ 
\par \hich\af0\dbch\af17\loch\f0 `define TRR 250 
\par \hich\af0\dbch\af17\loch\f0 `define TRD 200 
\par \hich\af0\dbch\af17\loch\f0 `define TDF 100 // max. time used 
\par \hich\af0\dbch\af17\loch\f0 /* write cycle  */ 
\par \hich\af0\dbch\af17\loch\f0 `define TWW 250 
\par \hich\af0\dbch\af17\loch\f0 `define TDW 150 
\par \hich\af0\dbch\af17\loch\f0 `define TWD 20 
\par \hich\af0\dbch\af17\loch\f0 `define TRV 6  // in terms of clock cycles 
\par \hich\af0\dbch\af17\loch\f0 /* other timing */ 
\par \hich\af0\dbch\af17\loch\f0 `define TTXRDY 8 //  8 clock cycle 
\par \hich\af0\dbch\af17\loch\f0  
\par \hich\af0\dbch\af17\loch\f0 input\tab rcd,  //receive data 
\par \hich\af0\dbch\af17\loch\f0         rxc_,  //receive clock  
\par \hich\af0\dbch\af17\loch\f0         txc_,  //transmit clock 
\par \hich\af0\dbch\af17\loch\f0         chipsel_, //chip selected when low 
\par \hich\af0\dbch\af17\loch\f0         comdat_,  //command /data_ select 
\par \hich\af0\dbch\af17\loch\f0         read_,write_, 
\par \hich\af0\dbch\af17\loch\f0         dsr_,  // data set ready 
\par \hich\af0\dbch\af17\loch\f0         cts_,  // clear to send 
\par \hich\af0\dbch\af17\loch\f0        reset, // reset when high 
\par \hich\af0\dbch\af17\loch\f0        clk,   // at least 30 times of the transmit/rexeibe data bit rates 
\par \hich\af0\dbch\af17\loch\f0        gnd, 
\par \hich\af0\dbch\af17\loch\f0  \hich\af0\dbch\af17\loch\f0       vcc; 
\par \hich\af0\dbch\af17\loch\f0 output\tab rxrdy, //receive data ready when high 
\par }\pard \s31\qj \fi425\li425\ri0\nowidctlpar\aspalpha\aspnum\faroman\rin0\lin425\itap0 {\f0 \hich\af0\dbch\af17\loch\f0 txd,  //transmit data lone  
\par \hich\af0\dbch\af17\loch\f0 txrdy, //transmit buffer ready to accept another byte to transfer 
\par \hich\af0\dbch\af17\loch\f0 txe,  // transmit buffer empty  
\par \hich\af0\dbch\af17\loch\f0 rts_,  // request to send 
\par \hich\af0\dbch\af17\loch\f0 dtr_; // data terminal ready 
\par }\pard \s31\qj \li0\ri0\nowidctlpar\aspalpha\aspnum\faroman\rin0\lin0\itap0 {\f0 \hich\af0\dbch\af17\loch\f0  
\par \hich\af0\dbch\af17\loch\f0 inout[7:0]\tab \hich\af0\dbch\af17\loch\f0 dbus; 
\par \hich\af0\dbch\af17\loch\f0 inout\tab syndet; //outside synchonous detect or output to indicate syn det  
\par \hich\af0\dbch\af17\loch\f0  
\par \hich\af0\dbch\af17\loch\f0 supply0\tab \tab gnd; 
\par \hich\af0\dbch\af17\loch\f0 supply1\tab \tab vcc; 
\par \hich\af0\dbch\af17\loch\f0  
\par \hich\af0\dbch\af17\loch\f0 reg \tab \tab \tab txd, rxrdy, txe, dtr_, rts_; 
\par \hich\af0\dbch\af17\loch\f0  
\par \hich\af0\dbch\af17\loch\f0 reg [7:0]\tab \tab receivebuf, rdata, status; 
\par 
\par \hich\af0\dbch\af17\loch\f0 //*****ADD BY FWN 
\par \hich\af0\dbch\af17\loch\f0 reg [3:0] dflags; 
\par \hich\af0\dbch\af17\loch\f0 reg [7:0] instance_id; 
\par \hich\af0\dbch\af17\loch\f0 reg read,chipel_; 
\par \hich\af0\dbch\af17\loch\f0 //*****
\par \hich\af0\dbch\af17\loch\f0   
\par \hich\af0\dbch\af17\loch\f0 reg\tab \tab recvdrv,\tab statusdrv; 
\par \hich\af0\dbch\af17\loch\f0  
\par \hich\af0\dbch\af17\loch\f0 // if recvdrv 1 dbus is driven by rdata 
\par \hich\af0\dbch\af17\loch\f0 assign\tab dbus = recvdrv ? rdata : 8'bz; //*****:,->; 
\par \hich\af0\dbch\af17\loch\f0 assign   dbus = statusdrv ? status : 8'bz ; //*****:->; assign abscent 
\par \hich\af0\dbch\af17\loch\f0  
\par \hich\af0\dbch\af17\loch\f0 reg [7:0]\tab command, 
\par }\pard \s31\qj \fi425\li850\ri0\nowidctlpar\aspalpha\aspnum\faroman\rin0\lin850\itap0 {\f0 \hich\af0\dbch\af17\loch\f0 tdata_out,\hich\af0\dbch\af17\loch\f0   // data being transmitted serially 
\par \hich\af0\dbch\af17\loch\f0 tdata_hold,  // data to be transmitted next if tdata_out is full 
\par \hich\af0\dbch\af17\loch\f0 sync1,sync2, // synchronous data bytes 
\par \hich\af0\dbch\af17\loch\f0 modreg; 
\par 
\par }\pard \s31\qj \li0\ri0\nowidctlpar\aspalpha\aspnum\faroman\rin0\lin0\itap0 {\f0 \hich\af0\dbch\af17\loch\f0 and (txrdy, status[0], command[0], ~cts_); 
\par \hich\af0\dbch\af17\loch\f0  
\par \hich\af0\dbch\af17\loch\f0 reg  transmitter_reset,      // set to 1 upon a reset ,cleared upon write data  
\par \hich\af0\dbch\af17\loch\f0        tdata_out_full,       // 1 if data in tdata_out has not been transmitted. 
\par \hich\af0\dbch\af17\loch\f0       tdata_hold_full,       // 1 if data in tdata_hold has not been transferred 
\par \hich\af0\dbch\af17\loch\f0            \hich\af0\dbch\af17\loch\f0                   // to tdata_out for serial transmission.  
\par }\pard\plain \qj \li0\ri0\nowidctlpar\aspalpha\aspnum\faroman\rin0\lin0\itap0 \fs21\lang1033\langfe2052\kerning2\loch\af0\hich\af0\dbch\af17\cgrid\langnp1033\langfenp2052 {\hich\af0\dbch\af17\loch\f0       tdata_hold_cts;           
\hich\af0\dbch\af17\loch\f0 // 1 if tdata_hold_full and it was cts when data 
\par \hich\af0\dbch\af17\loch\f0                              //   was transferred to tdata_hold.  
\par }\pard\plain \s31\qj \li0\ri0\nowidctlpar\aspalpha\aspnum\faroman\rin0\lin0\itap0 \fs21\lang1033\langfe2052\kerning2\loch\af17\hich\af2\dbch\af17\cgrid\langnp1033\langfenp2052 {\f0 \hich\af0\dbch\af17\loch\f0                              //   0 if tdata_h
\hich\af0\dbch\af17\loch\f0 old is empty or is full but was 
\par \hich\af0\dbch\af17\loch\f0                              //   filled  while it was not cts. 
\par \hich\af0\dbch\af17\loch\f0 reg  tdata_out_wait;          // 0 if a stop bit was just sent and we do not need 
\par \hich\af0\dbch\af17\loch\f0                              // to wait for a negedge on txc before transmi\hich\af0\dbch\af17\loch\f0 tting 
\par \hich\af0\dbch\af17\loch\f0 reg [7:0] syncmask; 
\par 
\par \hich\af0\dbch\af17\loch\f0 nmos  syndet_gate1(syndet,status[6], ~modreg[6]); 
\par \hich\af0\dbch\af17\loch\f0  
\par \hich\af0\dbch\af17\loch\f0 reg sync_to_receive;     // 1(2) if looking for 1st(2nd) sync on rxd 
\par \hich\af0\dbch\af17\loch\f0 reg syncs_received;      // 1 if sync chars received, 0 if lookinf for sync
\par \hich\af0\dbch\af17\loch\f0 reg rec_sync_index;      // \hich\af0\dbch\af17\loch\f0  indicating the syn. character to be matched 
\par \hich\af0\dbch\af17\loch\f0  
\par \hich\af0\dbch\af17\loch\f0 integer breakcount_period;  // number of clock periods to count as break 
\par \hich\af0\dbch\af17\loch\f0  
\par \hich\af0\dbch\af17\loch\f0 reg sync_to_transmit;       //1(2) if 1st(2nd) sync char should be sent next 
\par \hich\af0\dbch\af17\loch\f0  
\par \hich\af0\dbch\af17\loch\f0 reg [7:0] data_mask;        //masks off the data bits (if char size is not 8) 
\par \hich\af0\dbch\af17\loch\f0                           // temporary registers 
\par \hich\af0\dbch\af17\loch\f0 reg [1:0] csel;  //indicates what next write means if comdat_=1: 
\par \hich\af0\dbch\af17\loch\f0                 //(0=mode instruction ,1=sync1,2=sync2,3=comm\hich\af0\dbch\af17\loch\f0 and) 
\par \hich\af0\dbch\af17\loch\f0 reg [5:0]  \tab baudmx,  
\par }\pard \s31\qj \fi425\li850\ri0\nowidctlpar\aspalpha\aspnum\faroman\rin0\lin850\itap0 {\f0 \hich\af0\dbch\af17\loch\f0 tbaudcnt,  
\par \hich\af0\dbch\af17\loch\f0 rbaudcnt;   //  baud rate 
\par }\pard \s31\qj \li0\ri0\nowidctlpar\aspalpha\aspnum\faroman\rin0\lin0\itap0 {\f0 \hich\af0\dbch\af17\loch\f0 reg[7:0]  tstoptotal;   // no. of tranmit clock pulses for stop bit (0 if sync mode 
\par \hich\af0\dbch\af17\loch\f0 reg[3:0]  databits;    // no. of data bits in a character (5,6,7 or 8) 
\par \hich\af0\dbch\af17\loch\f0 reg  rdatain;         // a data \hich\af0\dbch\af17\loch\f0 byte is read in if 1 
\par \hich\af0\dbch\af17\loch\f0  
\par \hich\af0\dbch\af17\loch\f0 reg was_cts_when_received;  // 0:if cts_ was high when char was received 
\par \hich\af0\dbch\af17\loch\f0                             // 1:if cts_ was low wheb char was received 
\par \hich\af0\dbch\af17\loch\f0                             //    (and so char was sent before shutdown) 
\par \hich\af0\dbch\af17\loch\f0 event\tab  rese\hich\af0\dbch\af17\loch\f0 te, start_receiver_e,hunt_sysnc1_e; 
\par \hich\af0\dbch\af17\loch\f0 reg\tab  receive_in_progress; 
\par \hich\af0\dbch\af17\loch\f0 event \tab txende; 
\par \hich\af0\dbch\af17\loch\f0 /***   COMMUNICATION ERRORS    ***/ 
\par 
\par \hich\af0\dbch\af17\loch\f0 task frame_error; 
\par \hich\af0\dbch\af17\loch\f0 begin  
\par }\pard \s31\qj \fi425\li0\ri0\nowidctlpar\aspalpha\aspnum\faroman\rin0\lin0\itap0 {\f0 \hich\af0\dbch\af17\loch\f0 if(dflags[4]) 
\par }\pard \s31\qj \fi425\li425\ri0\nowidctlpar\aspalpha\aspnum\faroman\rin0\lin425\itap0 {\f0 \hich\af0\dbch\af17\loch\f0 $display("I8251A (%h)at %d: *** frame error ",instance_id,$time); 
\par }\pard \s31\qj \fi425\li0\ri0\nowidctlpar\aspalpha\aspnum\faroman\rin0\lin0\itap0 {\f0 \hich\af0\dbch\af17\loch\f0 status[5]=1; 
\par }\pard \s31\qj \li0\ri0\nowidctlpar\aspalpha\aspnum\faroman\rin0\lin0\itap0 {\f0 \hich\af0\dbch\af17\loch\f0 end 
\par \hich\af0\dbch\af17\loch\f0 endtask 
\par \hich\af0\dbch\af17\loch\f0  
\par \hich\af0\dbch\af17\loch\f0 task parity_error;
\par \hich\af0\dbch\af17\loch\f0 begin 
\par \hich\af0\dbch\af17\loch\f0 if(dflags[4]) 
\par }\pard \s31\qj \fi425\li0\ri0\nowidctlpar\aspalpha\aspnum\faroman\rin0\lin0\itap0 {\f0 \hich\af0\dbch\af17\loch\f0 $display("I8251A (%h)  at %d : ***parity error data: %b", 
\par }\pard \s31\qj \li0\ri0\nowidctlpar\aspalpha\aspnum\faroman\rin0\lin0\itap0 {\f0 \hich\af0\dbch\af17\loch\f0  \tab \tab \tab \tab \tab instance_id, $time, receivebuf); 
\par }\pard \s31\qj \fi425\li0\ri0\nowidctlpar\aspalpha\aspnum\faroman\rin0\lin0\itap0 {\f0 \hich\af0\dbch\af17\loch\f0 status[3]=1; 
\par }\pard \s31\qj \li0\ri0\nowidctlpar\aspalpha\aspnum\faroman\rin0\lin0\itap0 {\f0 \hich\af0\dbch\af17\loch\f0 end 
\par \hich\af0\dbch\af17\loch\f0 endtask 
\par \hich\af0\dbch\af17\loch\f0  
\par \hich\af0\dbch\af17\loch\f0 task overrun_error; 
\par \hich\af0\dbch\af17\loch\f0 begin 
\par \hich\af0\dbch\af17\loch\f0 if(dflags[4]) 
\par }\pard \s31\qj \fi425\li425\ri0\nowidctlpar\aspalpha\aspnum\faroman\rin0\lin425\itap0 {\f0 \hich\af0\dbch\af17\loch\f0 $display("I8251A (%h) at %d: *** oerrun er\hich\af0\dbch\af17\loch\f0 ror",instance_id,$time); 
\par }\pard \s31\qj \fi425\li0\ri0\nowidctlpar\aspalpha\aspnum\faroman\rin0\lin0\itap0 {\f0 \hich\af0\dbch\af17\loch\f0 status[4]=1; 
\par }\pard \s31\qj \li0\ri0\nowidctlpar\aspalpha\aspnum\faroman\rin0\lin0\itap0 {\f0 \hich\af0\dbch\af17\loch\f0 end 
\par \hich\af0\dbch\af17\loch\f0 endtask 
\par \hich\af0\dbch\af17\loch\f0  
\par \hich\af0\dbch\af17\loch\f0      /***       TIMING VIOLATIONS        ***/ 
\par \hich\af0\dbch\af17\loch\f0  
\par \hich\af0\dbch\af17\loch\f0 integer\tab time_dbus_setup, 
\par }\pard \s31\qj \fi425\li425\ri0\nowidctlpar\aspalpha\aspnum\faroman\rin0\lin425\itap0 {\f0 \hich\af0\dbch\af17\loch\f0 time_write_begin, 
\par \hich\af0\dbch\af17\loch\f0 time_write_end, 
\par \hich\af0\dbch\af17\loch\f0 time_read_begin, 
\par \hich\af0\dbch\af17\loch\f0 time_read_end, 
\par \hich\af0\dbch\af17\loch\f0 between_write_clks; //  to check between write recovery\hich\af0\dbch\af17\loch\f0  
\par }\pard \s31\qj \li0\ri0\nowidctlpar\aspalpha\aspnum\faroman\rin0\lin0\itap0 {\f0 \hich\af0\dbch\af17\loch\f0  
\par \hich\af0\dbch\af17\loch\f0 reg \tab \tab reset_signal_in;  //to check the reset signal pulse width 
\par \hich\af0\dbch\af17\loch\f0  
\par \hich\af0\dbch\af17\loch\f0 initial 
\par \hich\af0\dbch\af17\loch\f0 begin 
\par \hich\af0\dbch\af17\loch\f0 time_dbus_setup \tab = -9999; 
\par \hich\af0\dbch\af17\loch\f0 time_write_begin\tab = -9999; 
\par \hich\af0\dbch\af17\loch\f0 time_write_end\tab \tab = -9999; 
\par \hich\af0\dbch\af17\loch\f0 time_read_begin\tab \tab = -9999; 
\par \hich\af0\dbch\af17\loch\f0 time_read_end\tab \tab = -9999; 
\par \hich\af0\dbch\af17\loch\f0 between_write_clks\tab = `TRV; \tab \tab \hich\af0\dbch\af17\loch\f0 //start:TRV clk periods since last write 
\par \hich\af0\dbch\af17\loch\f0 end 
\par \hich\af0\dbch\af17\loch\f0  
\par \hich\af0\dbch\af17\loch\f0  
\par \hich\af0\dbch\af17\loch\f0 /***  Timing analysis for read cycles  ***/ 
\par \hich\af0\dbch\af17\loch\f0  
\par \hich\af0\dbch\af17\loch\f0 always @( negedge read_) 
\par \hich\af0\dbch\af17\loch\f0 if (chipsel_==0) 
\par \hich\af0\dbch\af17\loch\f0 begin  
\par }\pard \s31\qj \fi425\li0\ri0\nowidctlpar\aspalpha\aspnum\faroman\rin0\lin0\itap0 {\f0 \hich\af0\dbch\af17\loch\f0 time_read_begin = $time; 
\par \hich\af0\dbch\af17\loch\f0 read_address_watch; 
\par }\pard \s31\qj \li0\ri0\nowidctlpar\aspalpha\aspnum\faroman\rin0\lin0\itap0 {\f0 \hich\af0\dbch\af17\loch\f0 end 
\par \hich\af0\dbch\af17\loch\f0  
\par \hich\af0\dbch\af17\loch\f0 /* Timing violation :read pulse must be TRR ns */ 
\par \hich\af0\dbch\af17\loch\f0 a\hich\af0\dbch\af17\loch\f0 lways @(posedge read_) 
\par \hich\af0\dbch\af17\loch\f0 if  (chipsel_==0) 
\par \hich\af0\dbch\af17\loch\f0 begin 
\par }\pard \s31\qj \fi425\li0\ri0\nowidctlpar\aspalpha\aspnum\faroman\rin0\lin0\itap0 {\f0 \hich\af0\dbch\af17\loch\f0 disable read_address_watch; 
\par \hich\af0\dbch\af17\loch\f0 time_read_end = $time; 
\par \hich\af0\dbch\af17\loch\f0 if(dflags[3] && (($time-time_read_begin) < `TRR)) 
\par \hich\af0\dbch\af17\loch\f0 $display("I8251A (%h) at %d:  *** read pulse width violation",  
\par }\pard \s31\qj \fi425\li425\ri0\nowidctlpar\aspalpha\aspnum\faroman\rin0\lin425\itap0 {\f0 \hich\af0\dbch\af17\loch\f0       instance_id, $time); 
\par }\pard \s31\qj \li0\ri0\nowidctlpar\aspalpha\aspnum\faroman\rin0\lin0\itap0 {\f0 \hich\af0\dbch\af17\loch\f0 end 
\par \hich\af0\dbch\af17\loch\f0  
\par \hich\af0\dbch\af17\loch\f0 /* Timing violation :address (comdat_  and chipsel_) must be stable */ 
\par \hich\af0\dbch\af17\loch\f0 /*                          stable throughout read                  */ 
\par \hich\af0\dbch\af17\loch\f0 task read_address_watch; 
\par \hich\af0\dbch\af17\loch\f0      @(comdat_  or  chipsel_)   //if the  "address"  changes 
\par }\pard \s31\qj \fi425\li425\ri0\nowidctlpar\aspalpha\aspnum\faroman\rin0\lin425\itap0 {\f0 \hich\af0\dbch\af17\loch\f0 if (read ==0)        // \hich\af0\dbch\af17\loch\f0  and read_ did not change at the same time 
\par }\pard \s31\qj \fi425\li850\ri0\nowidctlpar\aspalpha\aspnum\faroman\rin0\lin850\itap0 {\f0 \hich\af0\dbch\af17\loch\f0 if  (dflags[3]) 
\par \hich\af0\dbch\af17\loch\f0 $display("I8251A  (%h)  at  %d : ***  address hold error on ready",  
\par }\pard \s31\qj \fi425\li3400\ri0\nowidctlpar\aspalpha\aspnum\faroman\rin0\lin3400\itap0 {\f0 \hich\af0\dbch\af17\loch\f0 instance_id, $time);  
\par }\pard \s31\qj \li0\ri0\nowidctlpar\aspalpha\aspnum\faroman\rin0\lin0\itap0 {\f0 \hich\af0\dbch\af17\loch\f0 endtask 
\par \hich\af0\dbch\af17\loch\f0  
\par \hich\af0\dbch\af17\loch\f0 /**  Timing analysis for write cycles  **/ 
\par \hich\af0\dbch\af17\loch\f0 always @(negedge write_) 
\par \hich\af0\dbch\af17\loch\f0 if  (chipsel_==0) 
\par \hich\af0\dbch\af17\loch\f0 be\hich\af0\dbch\af17\loch\f0 gin 
\par }\pard \s31\qj \li425\ri0\nowidctlpar\aspalpha\aspnum\faroman\rin0\lin425\itap0 {\f0 \hich\af0\dbch\af17\loch\f0 time_write_begin = $time; 
\par }\pard \s31\qj \fi425\li425\ri0\nowidctlpar\aspalpha\aspnum\faroman\rin0\lin425\itap0 {\f0 \hich\af0\dbch\af17\loch\f0 write_address_watch; 
\par }\pard \s31\qj \li0\ri0\nowidctlpar\aspalpha\aspnum\faroman\rin0\lin0\itap0 {\f0 \hich\af0\dbch\af17\loch\f0 end 
\par \hich\af0\dbch\af17\loch\f0  
\par \hich\af0\dbch\af17\loch\f0 /*  Timing violation : read pulse must be TRR ns */ 
\par \hich\af0\dbch\af17\loch\f0 /*  Timing violation : TDW ns bus setup time before posedge write_  */ 
\par \hich\af0\dbch\af17\loch\f0 /*  Timing violation : TWD ns bus hold time after posedge write_  */ 
\par \hich\af0\dbch\af17\loch\f0  
\par \hich\af0\dbch\af17\loch\f0 always @(posedge write_) 
\par \hich\af0\dbch\af17\loch\f0 if (chipsel_==0) 
\par \hich\af0\dbch\af17\loch\f0 begin 
\par }\pard \s31\qj \fi425\li0\ri0\nowidctlpar\aspalpha\aspnum\faroman\rin0\lin0\itap0 {\f0 \hich\af0\dbch\af17\loch\f0 disable write_address_watch; 
\par \hich\af0\dbch\af17\loch\f0 time_write_end=$time; 
\par \hich\af0\dbch\af17\loch\f0 if(dflags[3]  &&  (($time-time_write_begin)  < `TWW)) 
\par \hich\af0\dbch\af17\loch\f0 $display("I8251A (%h) at %d:  *** write pulse 
\par }\pard \s31\qj \fi425\li2550\ri0\nowidctlpar\aspalpha\aspnum\faroman\rin0\lin2550\itap0 {\f0 \hich\af0\dbch\af17\loch\f0 width violation",instance_id,$time);   
\par }\pard \s31\qj \li0\ri0\nowidctlpar\aspalpha\aspnum\faroman\rin0\lin0\itap0 {\f0 \hich\af0\dbch\af17\loch\f0 end 
\par \hich\af0\dbch\af17\loch\f0  
\par \hich\af0\dbch\af17\loch\f0 a\hich\af0\dbch\af17\loch\f0 lways @dbus 
\par \hich\af0\dbch\af17\loch\f0 begin 
\par }\pard \s31\qj \fi425\li0\ri0\nowidctlpar\aspalpha\aspnum\faroman\rin0\lin0\itap0 {\f0 \hich\af0\dbch\af17\loch\f0 time_dbus_setup\tab = $time; 
\par }\pard \s31\qj \fi425\li425\ri0\nowidctlpar\aspalpha\aspnum\faroman\rin0\lin425\itap0 {\f0 \hich\af0\dbch\af17\loch\f0 if(dflags[3] && (($time-time_write_end <  `TWD))) 
\par }\pard \s31\qj \fi425\li850\ri0\nowidctlpar\aspalpha\aspnum\faroman\rin0\lin850\itap0 {\f0 \hich\af0\dbch\af17\loch\f0 $display("I8251A (%h) at %d: *** datahold violation on write",
\par \hich\af0\dbch\af17\loch\f0                                       instance_id ,$time); 
\par }\pard \s31\qj \li0\ri0\nowidctlpar\aspalpha\aspnum\faroman\rin0\lin0\itap0 {\f0 \hich\af0\dbch\af17\loch\f0 end 
\par \hich\af0\dbch\af17\loch\f0  
\par \hich\af0\dbch\af17\loch\f0 /*   Timing violation: addres\hich\af0\dbch\af17\loch\f0 s (comdat_ and chipsel_ ) must be stable*/ 
\par \hich\af0\dbch\af17\loch\f0 /*                       stable throughout write                   */ 
\par \hich\af0\dbch\af17\loch\f0 task write_address_watch; 
\par }\pard \s31\qj \fi425\li0\ri0\nowidctlpar\aspalpha\aspnum\faroman\rin0\lin0\itap0 {\f0 \hich\af0\dbch\af17\loch\f0 @(comdat_  or  chipsel_ )  //if the "address" changes 
\par }\pard \s31\qj \fi425\li425\ri0\nowidctlpar\aspalpha\aspnum\faroman\rin0\lin425\itap0 {\f0 \hich\af0\dbch\af17\loch\f0 if  (wri\hich\af0\dbch\af17\loch\f0 te_==0)     //  and write_ did not  change at the same time 
\par }\pard \s31\qj \fi425\li850\ri0\nowidctlpar\aspalpha\aspnum\faroman\rin0\lin850\itap0 {\f0 \hich\af0\dbch\af17\loch\f0 if (dflags[3]) 
\par }\pard \s31\qj \fi425\li1275\ri0\nowidctlpar\aspalpha\aspnum\faroman\rin0\lin1275\itap0 {\f0 \hich\af0\dbch\af17\loch\f0 $display("I8251A (%h) at %d: *** address hold error on write",
\par \hich\af0\dbch\af17\loch\f0                                         instance_id , $time); 
\par }\pard \s31\qj \li0\ri0\nowidctlpar\aspalpha\aspnum\faroman\rin0\lin0\itap0 {\f0 \hich\af0\dbch\af17\loch\f0 endtask 
\par \hich\af0\dbch\af17\loch\f0  
\par \hich\af0\dbch\af17\loch\f0 /*  Timing violation: minimum of TRV clk c\hich\af0\dbch\af17\loch\f0 ycles between writes */ 
\par \hich\af0\dbch\af17\loch\f0 always @( negedge write_ )  
\par \hich\af0\dbch\af17\loch\f0 if ( chipel_==0 ) 
\par \hich\af0\dbch\af17\loch\f0 begin 
\par }\pard \s31\qj \fi425\li0\ri0\nowidctlpar\aspalpha\aspnum\faroman\rin0\lin0\itap0 {\f0 \hich\af0\dbch\af17\loch\f0 time_write_begin=$time; 
\par \hich\af0\dbch\af17\loch\f0 if(dflags[3] && between_write_clks < `TRV) 
\par }\pard \s31\qj \fi425\li425\ri0\nowidctlpar\aspalpha\aspnum\faroman\rin0\lin425\itap0 {\f0 \hich\af0\dbch\af17\loch\f0 $display("I8251A (%h) at %d: ***between write recovery violation",
\par \hich\af0\dbch\af17\loch\f0                                         \hich\af0\dbch\af17\loch\f0         instance_id,$time); 
\par }\pard \s31\qj \li0\ri0\nowidctlpar\aspalpha\aspnum\faroman\rin0\lin0\itap0 {\f0 \hich\af0\dbch\af17\loch\f0 end 
\par \hich\af0\dbch\af17\loch\f0  
\par \hich\af0\dbch\af17\loch\f0 always  @(negedge write_) 
\par }\pard \s31\qj \fi425\li0\ri0\nowidctlpar\aspalpha\aspnum\faroman\rin0\lin0\itap0 {\f0 \hich\af0\dbch\af17\loch\f0 repeat (`TRV) @(posedge clk) 
\par \hich\af0\dbch\af17\loch\f0 between_write_clks = between_write_clks +1 ; 
\par }\pard \s31\qj \li0\ri0\nowidctlpar\aspalpha\aspnum\faroman\rin0\lin0\itap0 {\f0 \hich\af0\dbch\af17\loch\f0  
\par \hich\af0\dbch\af17\loch\f0 /**Timing analysis for reset sequence  **/ 
\par \hich\af0\dbch\af17\loch\f0 /*      Timing violation : reset pulse must be 6 clk cycles  */ 
\par \hich\af0\dbch\af17\loch\f0  
\par \hich\af0\dbch\af17\loch\f0 alwa\hich\af0\dbch\af17\loch\f0 ys @(posedge reset ) 
\par \hich\af0\dbch\af17\loch\f0 begin : reset_block 
\par }\pard \s31\qj \fi425\li0\ri0\nowidctlpar\aspalpha\aspnum\faroman\rin0\lin0\itap0 {\f0 \hich\af0\dbch\af17\loch\f0 reset_signal_in=1; 
\par \hich\af0\dbch\af17\loch\f0 repeat(6)  @(posedge clk); 
\par \hich\af0\dbch\af17\loch\f0 reset_signal_in=0; 
\par \hich\af0\dbch\af17\loch\f0 //external reset 
\par \hich\af0\dbch\af17\loch\f0 -> resete; 
\par }\pard \s31\qj \li0\ri0\nowidctlpar\aspalpha\aspnum\faroman\rin0\lin0\itap0 {\f0 \hich\af0\dbch\af17\loch\f0 end 
\par 
\par \hich\af0\dbch\af17\loch\f0 always @(negedge reset) 
\par \hich\af0\dbch\af17\loch\f0 begin 
\par }\pard \s31\qj \fi425\li0\ri0\nowidctlpar\aspalpha\aspnum\faroman\rin0\lin0\itap0 {\f0 \hich\af0\dbch\af17\loch\f0 if(dflags[3]  && (reset_signal_in==1)) 
\par }\pard \s31\qj \li0\ri0\nowidctlpar\aspalpha\aspnum\faroman\rin0\lin0\itap0 {\f0 \hich\af0\dbch\af17\loch\f0        $display("I8251A (%h) at %d: *** reset pulse too short ", instance_id ,
\par \hich\af0\dbch\af17\loch\f0                                             $time);// lack of ; 
\par \hich\af0\dbch\af17\loch\f0  
\par \hich\af0\dbch\af17\loch\f0 disable reset_block; 
\par \hich\af0\dbch\af17\loch\f0 end 
\par \hich\af0\dbch\af17\loch\f0  
\par \hich\af0\dbch\af17\loch\f0 /***  BEHAVIORAL DESCRIPTION   ***/ 
\par \hich\af0\dbch\af17\loch\f0 /*  Reset sequence  */ 
\par \hich\af0\dbch\af17\loch\f0 initial 
\par \hich\af0\dbch\af17\loch\f0 begin  //po\hich\af0\dbch\af17\loch\f0 wer-on reset  
\par }\pard \s31\qj \fi425\li0\ri0\nowidctlpar\aspalpha\aspnum\faroman\rin0\lin0\itap0 {\f0 \hich\af0\dbch\af17\loch\f0 reset_signal_in=0; 
\par \hich\af0\dbch\af17\loch\f0 -> resete; 
\par }\pard \s31\qj \li0\ri0\nowidctlpar\aspalpha\aspnum\faroman\rin0\lin0\itap0 {\f0 \hich\af0\dbch\af17\loch\f0 end 
\par \hich\af0\dbch\af17\loch\f0  
\par \hich\af0\dbch\af17\loch\f0 always @ resete 
\par \hich\af0\dbch\af17\loch\f0 begin 
\par }\pard \s31\qj \fi425\li0\ri0\nowidctlpar\aspalpha\aspnum\faroman\rin0\lin0\itap0 {\f0 \hich\af0\dbch\af17\loch\f0 if(dflags[5]) 
\par }\pard \s31\qj \fi425\li425\ri0\nowidctlpar\aspalpha\aspnum\faroman\rin0\lin425\itap0 {\f0 \hich\af0\dbch\af17\loch\f0 $display("I8251A  (%h)  at  %d : performing reset sequence",  
\par }\pard \s31\qj \li0\ri0\nowidctlpar\aspalpha\aspnum\faroman\rin0\lin0\itap0 {\f0 \hich\af0\dbch\af17\loch\f0                                                 instance_id, $time); 
\par }\pard \s31\qj \fi425\li0\ri0\nowidctlpar\aspalpha\aspnum\faroman\rin0\lin0\itap0 {\f0 \hich\af0\dbch\af17\loch\f0 csel=0; 
\par \hich\af0\dbch\af17\loch\f0 transmitter_reset=1; 
\par \hich\af0\dbch\af17\loch\f0 tdata_out_full=0; 
\par \hich\af0\dbch\af17\loch\f0 tdata_out_wait=0; 
\par \hich\af0\dbch\af17\loch\f0 tdata_hold_full=0; 
\par \hich\af0\dbch\af17\loch\f0 tdata_hold_cts=0; 
\par \hich\af0\dbch\af17\loch\f0 rdatain=0; 
\par \hich\af0\dbch\af17\loch\f0 status=4;  //only txe  is set 
\par \hich\af0\dbch\af17\loch\f0 txe=1; 
\par \hich\af0\dbch\af17\loch\f0 statusdrv=0; 
\par \hich\af0\dbch\af17\loch\f0 recvdrv=0; 
\par \hich\af0\dbch\af17\loch\f0 txd=1;  //line at mark state upon reset until data is transmitted 
\par }\pard \s31\qj \li0\ri0\nowidctlpar\aspalpha\aspnum\faroman\rin0\lin0\itap0 {\f0 \hich\af0\dbch\af17\loch\f0         \tab \tab // assign not allowed fo\hich\af0\dbch\af17\loch\f0 r status ,etc. 
\par }\pard \s31\qj \fi425\li0\ri0\nowidctlpar\aspalpha\aspnum\faroman\rin0\lin0\itap0 {\f0 \hich\af0\dbch\af17\loch\f0 rxrdy=0; 
\par \hich\af0\dbch\af17\loch\f0 command=0; 
\par \hich\af0\dbch\af17\loch\f0 dtr_=1; 
\par \hich\af0\dbch\af17\loch\f0 rts_=1; 
\par \hich\af0\dbch\af17\loch\f0 status[6]=0;         //  syndat is reset to output low 
\par \hich\af0\dbch\af17\loch\f0 sync_to_transmit=1;  //transmit sync char #1 when sync are transmit 
\par \hich\af0\dbch\af17\loch\f0 sync_to_receive=1; 
\par \hich\af0\dbch\af17\loch\f0 between_write_clks = `TRV; 
\par \hich\af0\dbch\af17\loch\f0 receive_in_progress=0; 
\par \hich\af0\dbch\af17\loch\f0 dis\hich\af0\dbch\af17\loch\f0 able read_address_watch; 
\par \hich\af0\dbch\af17\loch\f0 disable write_address_watch; 
\par \hich\af0\dbch\af17\loch\f0 disable trans1; 
\par \hich\af0\dbch\af17\loch\f0 disable trans2; 
\par \hich\af0\dbch\af17\loch\f0 disable trans3; 
\par \hich\af0\dbch\af17\loch\f0 disable trans4; 
\par \hich\af0\dbch\af17\loch\f0 disable rcv_blk; 
\par \hich\af0\dbch\af17\loch\f0 disable sync_hunt_blk;  
\par \hich\af0\dbch\af17\loch\f0 disable double_sync_hunt_blk; 
\par \hich\af0\dbch\af17\loch\f0 disable parity_sync_hunt_blk; 
\par \hich\af0\dbch\af17\loch\f0 disable syn_receive_internal; 
\par \hich\af0\dbch\af17\loch\f0 disable asyn_receive; 
\par \hich\af0\dbch\af17\loch\f0 disable break_detect_blk; 
\par \hich\af0\dbch\af17\loch\f0 disable break_delay_blk; 
\par }\pard \s31\qj \li0\ri0\nowidctlpar\aspalpha\aspnum\faroman\rin0\lin0\itap0 {\f0 \hich\af0\dbch\af17\loch\f0 end 
\par \hich\af0\dbch\af17\loch\f0  
\par \hich\af0\dbch\af17\loch\f0 always @ ( negedge read_) 
\par }\pard \s31\qj \fi425\li0\ri0\nowidctlpar\aspalpha\aspnum\faroman\rin0\lin0\itap0 {\f0 \hich\af0\dbch\af17\loch\f0 if (chipsel_==0) 
\par }\pard \s31\qj \fi425\li425\ri0\nowidctlpar\aspalpha\aspnum\faroman\rin0\lin425\itap0 {\f0 \hich\af0\dbch\af17\loch\f0 begin 
\par }\pard \s31\qj \li0\ri0\nowidctlpar\aspalpha\aspnum\faroman\rin0\lin0\itap0 {\f0 \hich\af0\dbch\af17\loch\f0    \tab \tab \tab #(`TRD)  // time for data to show on the data bus 
\par }\pard \s31\qj \fi425\li850\ri0\nowidctlpar\aspalpha\aspnum\faroman\rin0\lin850\itap0 {\f0 \hich\af0\dbch\af17\loch\f0 if (comdat_==0)  //8251A DATA ==>\hich\af0\dbch\af17\loch\f0  DATA BUS 
\par }\pard \s31\qj \fi425\li1275\ri0\nowidctlpar\aspalpha\aspnum\faroman\rin0\lin1275\itap0 {\f0 \hich\af0\dbch\af17\loch\f0 begin 
\par }\pard \s31\qj \fi425\li1700\ri0\nowidctlpar\aspalpha\aspnum\faroman\rin0\lin1700\itap0 {\f0 \hich\af0\dbch\af17\loch\f0 recvdrv=1; 
\par \hich\af0\dbch\af17\loch\f0 rdatain=0; // no receive byte is ready 
\par \hich\af0\dbch\af17\loch\f0 rxrdy=0; 
\par \hich\af0\dbch\af17\loch\f0 status[1]=0; 
\par }\pard \s31\qj \fi425\li1275\ri0\nowidctlpar\aspalpha\aspnum\faroman\rin0\lin1275\itap0 {\f0 \hich\af0\dbch\af17\loch\f0 end              
\par }\pard \s31\qj \fi425\li850\ri0\nowidctlpar\aspalpha\aspnum\faroman\rin0\lin850\itap0 {\f0 \hich\af0\dbch\af17\loch\f0 else  // 8251A STATUS  ==> DATA  BUS 
\par }\pard \s31\qj \fi425\li1275\ri0\nowidctlpar\aspalpha\aspnum\faroman\rin0\lin1275\itap0 {\f0 \hich\af0\dbch\af17\loch\f0 begin  
\par }\pard \s31\qj \fi425\li1700\ri0\nowidctlpar\aspalpha\aspnum\faroman\rin0\lin1700\itap0 {\f0 \hich\af0\dbch\af17\loch\f0 statusdrv=1; 
\par }\pard \s31\qj \fi425\li2125\ri0\nowidctlpar\aspalpha\aspnum\faroman\rin0\lin2125\itap0 {\f0 \hich\af0\dbch\af17\loch\f0 if (modreg [1:0] ==2'b00)  // if sync mode 
\par }\pard \s31\qj \fi425\li2550\ri0\nowidctlpar\aspalpha\aspnum\faroman\rin0\lin2550\itap0 {\f0 \hich\af0\dbch\af17\loch\f0 status[6]=0;    // reset syndet upon status ready 
\par }\pard \s31\qj \fi425\li850\ri0\nowidctlpar\aspalpha\aspnum\faroman\rin0\lin850\itap0 {\f0 \hich\af0\dbch\af17\loch\f0 //note: is only reset upon reset or rxd=1 in async mode 
\par }\pard \s31\qj \fi425\li1275\ri0\nowidctlpar\aspalpha\aspnum\faroman\rin0\lin1275\itap0 {\f0 \hich\af0\dbch\af17\loch\f0 end 
\par }\pard \s31\qj \fi425\li0\ri0\nowidctlpar\aspalpha\aspnum\faroman\rin0\lin0\itap0 {\f0 \hich\af0\dbch\af17\loch\f0 end 
\par }\pard \s31\qj \li0\ri0\nowidctlpar\aspalpha\aspnum\faroman\rin0\lin0\itap0 {\f0 \hich\af0\dbch\af17\loch\f0  
\par \hich\af0\dbch\af17\loch\f0 always @ ( posedge read_) 
\par \hich\af0\dbch\af17\loch\f0 begin  
\par }\pard \s31\qj \fi425\li0\ri0\nowidctlpar\aspalpha\aspnum\faroman\rin0\lin0\itap0 {\f0 \hich\af0\dbch\af17\loch\f0 #(`TDF)  //data from read stays on the bus after posedge read_ 
\par \hich\af0\dbch\af17\loch\f0 recvdrv=0; 
\par \hich\af0\dbch\af17\loch\f0 statusdrv=0; 
\par }\pard \s31\qj \li0\ri0\nowidctlpar\aspalpha\aspnum\faroman\rin0\lin0\itap0 {\f0 \hich\af0\dbch\af17\loch\f0 end 
\par \hich\af0\dbch\af17\loch\f0  
\par \hich\af0\dbch\af17\loch\f0 alwa\hich\af0\dbch\af17\loch\f0 ys @(negedge write_) 
\par \hich\af0\dbch\af17\loch\f0 begin 
\par }\pard \s31\qj \fi425\li0\ri0\nowidctlpar\aspalpha\aspnum\faroman\rin0\lin0\itap0 {\f0 \hich\af0\dbch\af17\loch\f0 if((chipsel_==0)&&(comdat_==0)) 
\par }\pard \s31\qj \fi425\li425\ri0\nowidctlpar\aspalpha\aspnum\faroman\rin0\lin425\itap0 {\f0 \hich\af0\dbch\af17\loch\f0 begin 
\par }\pard \s31\qj \fi425\li850\ri0\nowidctlpar\aspalpha\aspnum\faroman\rin0\lin850\itap0 {\f0 \hich\af0\dbch\af17\loch\f0 txe=0; 
\par \hich\af0\dbch\af17\loch\f0 status[2]=0;//transmitter not empty after receiving data 
\par \hich\af0\dbch\af17\loch\f0 status[0]=0;//transmitter not ready after receiving data 
\par }\pard \s31\qj \fi425\li425\ri0\nowidctlpar\aspalpha\aspnum\faroman\rin0\lin425\itap0 {\f0 \hich\af0\dbch\af17\loch\f0 end 
\par }\pard \s31\qj \li0\ri0\nowidctlpar\aspalpha\aspnum\faroman\rin0\lin0\itap0 {\f0 \hich\af0\dbch\af17\loch\f0 end 
\par \hich\af0\dbch\af17\loch\f0  
\par \hich\af0\dbch\af17\loch\f0  
\par \hich\af0\dbch\af17\loch\f0 always @(posedge write_)             //read t\hich\af0\dbch\af17\loch\f0 he command/data from the CPU 
\par }\pard \s31\qj \li0\ri0\nowidctlpar\tx525\aspalpha\aspnum\faroman\rin0\lin0\itap0 {\f0 \hich\af0\dbch\af17\loch\f0 if (chipsel_==0) 
\par }\pard \s31\qj \fi425\li0\ri0\nowidctlpar\aspalpha\aspnum\faroman\rin0\lin0\itap0 {\f0 \hich\af0\dbch\af17\loch\f0 begin  
\par }\pard \s31\qj \fi425\li425\ri0\nowidctlpar\aspalpha\aspnum\faroman\rin0\lin425\itap0 {\f0 \hich\af0\dbch\af17\loch\f0 if (comdat_==0)    //DATA BUS ==> 8251A DATA 
\par }\pard \s31\qj \fi425\li850\ri0\nowidctlpar\aspalpha\aspnum\faroman\rin0\lin850\itap0 {\f0 \hich\af0\dbch\af17\loch\f0 begin  
\par }\pard \s31\qj \fi425\li1275\ri0\nowidctlpar\aspalpha\aspnum\faroman\rin0\lin1275\itap0 {\f0 \hich\af0\dbch\af17\loch\f0 case  (command[0]  & ~ cts_) 
\par \hich\af0\dbch\af17\loch\f0 0:                  //if it is not clear to send 
\par }\pard \s31\qj \fi425\li1700\ri0\nowidctlpar\aspalpha\aspnum\faroman\rin0\lin1700\itap0 {\f0 \hich\af0\dbch\af17\loch\f0 begin 
\par }\pard \s31\qj \fi425\li2125\ri0\nowidctlpar\aspalpha\aspnum\faroman\rin0\lin2125\itap0 {\f0 \hich\af0\dbch\af17\loch\f0 tdata_hold=dbus; 
\par \hich\af0\dbch\af17\loch\f0 tdata_hold_full=1; //then mark the data a\hich\af0\dbch\af17\loch\f0 s received and 
\par \hich\af0\dbch\af17\loch\f0 tdata_hold_cts=0;  //  that it should be sent when cts 
\par }\pard \s31\qj \fi425\li1700\ri0\nowidctlpar\aspalpha\aspnum\faroman\rin0\lin1700\itap0 {\f0 \hich\af0\dbch\af17\loch\f0 end 
\par }\pard \s31\qj \fi425\li1275\ri0\nowidctlpar\aspalpha\aspnum\faroman\rin0\lin1275\itap0 {\f0 \hich\af0\dbch\af17\loch\f0 1:                      // if it is clear to send }{\f0 \loch\af0\hich\af0\dbch\f17 \'a1\'ad}{\f0 \hich\af0\dbch\af17\loch\f0  
\par }\pard \s31\qj \fi425\li1700\ri0\nowidctlpar\aspalpha\aspnum\faroman\rin0\lin1700\itap0 {\f0 \hich\af0\dbch\af17\loch\f0 if(transmitter_reset) //  }{\f0 \loch\af0\hich\af0\dbch\f17 \'a1\'ad}{\f0 \hich\af0\dbch\af17\loch\f0 
 and this is 1st data since reset 
\par }\pard \s31\qj \fi425\li2125\ri0\nowidctlpar\aspalpha\aspnum\faroman\rin0\lin2125\itap0 {\f0 \hich\af0\dbch\af17\loch\f0 begin 
\par }\pard \s31\qj \fi605\li2125\ri0\nowidctlpar\aspalpha\aspnum\faroman\rin0\lin2125\itap0 {\f0 \hich\af0\dbch\af17\loch\f0 transmitter_reset=0; 
\par \hich\af0\dbch\af17\loch\f0 tdata_out=dbus; 
\par \hich\af0\dbch\af17\loch\f0 tdata_out_wait=1; \hich\af0\dbch\af17\loch\f0  //   then wait for a negedge on txc  
\par \hich\af0\dbch\af17\loch\f0 tdata_out_full=1;  //   and transmit the data 
\par \hich\af0\dbch\af17\loch\f0 tdata_hold_full=0; 
\par \hich\af0\dbch\af17\loch\f0 tdata_hold_cts=0; 
\par \hich\af0\dbch\af17\loch\f0 repeat(`TTXRDY)  @(posedge clk); 
\par \hich\af0\dbch\af17\loch\f0 status[0]=1;        // and set the txrdy status bit 
\par }\pard \s31\qj \fi425\li2125\ri0\nowidctlpar\aspalpha\aspnum\faroman\rin0\lin2125\itap0 {\f0 \hich\af0\dbch\af17\loch\f0 end 
\par }\pard \s31\qj \fi425\li1700\ri0\nowidctlpar\aspalpha\aspnum\faroman\rin0\lin1700\itap0 {\f0 \hich\af0\dbch\af17\loch\f0 else 
\par }\pard \s31\qj \fi425\li2125\ri0\nowidctlpar\aspalpha\aspnum\faroman\rin0\lin2125\itap0 {\f0 \hich\af0\dbch\af17\loch\f0 begin  
\par }\pard \s31\qj \fi2730\li0\ri0\nowidctlpar\aspalpha\aspnum\faroman\rin0\lin0\itap0 {\f0 \hich\af0\dbch\af17\loch\f0 tdata_hold=dbus;  // then\hich\af0\dbch\af17\loch\f0  mark the data as being receive 
\par \hich\af0\dbch\af17\loch\f0 tdata_hold_full=1; //  and that it should be transmitted 
\par \hich\af0\dbch\af17\loch\f0 tdata_hold_cts=1;  //  it becomes not cts, 
\par \hich\af0\dbch\af17\loch\f0 // but do not set the txrdy status bit 
\par }\pard \s31\qj \fi425\li2125\ri0\nowidctlpar\aspalpha\aspnum\faroman\rin0\lin2125\itap0 {\f0 \hich\af0\dbch\af17\loch\f0 end 
\par }\pard \s31\qj \fi830\li850\ri0\nowidctlpar\aspalpha\aspnum\faroman\rin0\lin850\itap0 {\f0 \hich\af0\dbch\af17\loch\f0 endcase 
\par }\pard \s31\qj \fi840\li0\ri0\nowidctlpar\aspalpha\aspnum\faroman\rin0\lin0\itap0 {\f0 \hich\af0\dbch\af17\loch\f0 end 
\par \hich\af0\dbch\af17\loch\f0 else                        //   DATA BUS ==> CONTROL 
\par }\pard \s31\qj \fi425\li850\ri0\nowidctlpar\aspalpha\aspnum\faroman\rin0\lin850\itap0 {\f0 \hich\af0\dbch\af17\loch\f0 begin 
\par }\pard \s31\qj \fi425\li1275\ri0\nowidctlpar\aspalpha\aspnum\faroman\rin0\lin1275\itap0 {\f0 \hich\af0\dbch\af17\loch\f0 case  (csel) 
\par \hich\af0\dbch\af17\loch\f0 0:                     // case 0: MODE INSTRUCTION 
\par }\pard \s31\qj \fi425\li1700\ri0\nowidctlpar\aspalpha\aspnum\faroman\rin0\lin1700\itap0 {\f0 \hich\af0\dbch\af17\loch\f0 begin 
\par }\pard \s31\qj \fi425\li2125\ri0\nowidctlpar\aspalpha\aspnum\faroman\rin0\lin2125\itap0 {\f0 \hich\af0\dbch\af17\loch\f0 modreg=dbus; 
\par \hich\af0\dbch\af17\loch\f0 if(modreg[1:0]==0)   //  synchronous mode 
\par \hich\af0\dbch\af17\loch\f0 begin 
\par }\pard \s31\qj \fi425\li2550\ri0\nowidctlpar\aspalpha\aspnum\faroman\rin0\lin2550\itap0 {\f0 \hich\af0\dbch\af17\loch\f0 csel=1; 
\par \hich\af0\dbch\af17\loch\f0 baudmx=1; 
\par \hich\af0\dbch\af17\loch\f0 tstoptotal=0;  //  no stop bit for synch. Op. 
\par }\pard \s31\qj \fi425\li2125\ri0\nowidctlpar\aspalpha\aspnum\faroman\rin0\lin2125\itap0 {\f0 \hich\af0\dbch\af17\loch\f0 end 
\par \hich\af0\dbch\af17\loch\f0 else              //synchronous mode 
\par }\pard \s31\qj \fi425\li2550\ri0\nowidctlpar\aspalpha\aspnum\faroman\rin0\lin2550\itap0 {\f0 \hich\af0\dbch\af17\loch\f0 begin 
\par }\pard \s31\qj \fi425\li2975\ri0\nowidctlpar\aspalpha\aspnum\faroman\rin0\lin2975\itap0 {\f0 \hich\af0\dbch\af17\loch\f0 cs\hich\af0\dbch\af17\loch\f0 el=3; 
\par \hich\af0\dbch\af17\loch\f0 baudmx=1;  //1X baud rate 
\par \hich\af0\dbch\af17\loch\f0 if (modreg[1:0]==2'b10) baudmx=16; 
\par \hich\af0\dbch\af17\loch\f0 if(modreg[1:0]==2'b11)  baudmx=64; 
\par \hich\af0\dbch\af17\loch\f0 //set up the stop bits in clocks 
\par \hich\af0\dbch\af17\loch\f0 tstoptotal=baudmx; 
\par \hich\af0\dbch\af17\loch\f0 if(modreg[7:6]==2'b10)
\par \hich\af0\dbch\af17\loch\f0     tstoptotal= tstoptotal + baudmx/2; 
\par }\pard \s31\qj \li3400\ri0\nowidctlpar\aspalpha\aspnum\faroman\rin0\lin3400\itap0 {\f0 \hich\af0\dbch\af17\loch\f0 if(modreg[7:6]==2'b11)
\par \hich\af0\dbch\af17\loch\f0     tstopt\hich\af0\dbch\af17\loch\f0 otal= tstoptotal+tstoptotal; 
\par }\pard \s31\qj \fi425\li2550\ri0\nowidctlpar\aspalpha\aspnum\faroman\rin0\lin2550\itap0 {\f0 \hich\af0\dbch\af17\loch\f0 end 
\par }\pard \s31\qj \fi425\li2125\ri0\nowidctlpar\aspalpha\aspnum\faroman\rin0\lin2125\itap0 {\f0 \hich\af0\dbch\af17\loch\f0 databits=modreg[3:2]+5;  // bits per char 
\par \hich\af0\dbch\af17\loch\f0 data_mask=255 >> (3-modreg[3:2]); 
\par }\pard \s31\qj \fi425\li1700\ri0\nowidctlpar\aspalpha\aspnum\faroman\rin0\lin1700\itap0 {\f0 \hich\af0\dbch\af17\loch\f0 end 
\par }\pard \s31\qj \li0\ri0\nowidctlpar\aspalpha\aspnum\faroman\rin0\lin0\itap0 {\f0 \hich\af0\dbch\af17\loch\f0  
\par }\pard \s31\qj \fi425\li1275\ri0\nowidctlpar\aspalpha\aspnum\faroman\rin0\lin1275\itap0 {\f0 \hich\af0\dbch\af17\loch\f0 1:            //case 1:  1st  SYNC CHAR  -SYNC MODE 
\par }\pard \s31\qj \fi425\li1700\ri0\nowidctlpar\aspalpha\aspnum\faroman\rin0\lin1700\itap0 {\f0 \hich\af0\dbch\af17\loch\f0 begin 
\par }\pard \s31\qj \fi425\li2125\ri0\nowidctlpar\aspalpha\aspnum\faroman\rin0\lin2125\itap0 {\f0 \hich\af0\dbch\af17\loch\f0 sync1=dbus; 
\par \hich\af0\dbch\af17\loch\f0 /* the syn. character will be adjusted to the most 
\par }\pard \s31\qj \fi425\li2550\ri0\nowidctlpar\aspalpha\aspnum\faroman\rin0\lin2550\itap0 {\f0 \hich\af0\dbch\af17\loch\f0 significant\hich\af0\dbch\af17\loch\f0  bit to simplify syn, hunt, 
\par }\pard \s31\qj \fi425\li2125\ri0\nowidctlpar\aspalpha\aspnum\faroman\rin0\lin2125\itap0 {\f0 \hich\af0\dbch\af17\loch\f0 syncmask is also set to test the top data bits   */ 
\par \hich\af0\dbch\af17\loch\f0 case  (modreg[3:2]) 
\par \hich\af0\dbch\af17\loch\f0 0: 
\par }\pard \s31\qj \fi2835\li0\ri0\nowidctlpar\aspalpha\aspnum\faroman\rin0\lin0\itap0 {\f0 \hich\af0\dbch\af17\loch\f0 begin 
\par }\pard \s31\qj \fi2835\li565\ri0\nowidctlpar\aspalpha\aspnum\faroman\rin0\lin565\itap0 {\f0 \hich\af0\dbch\af17\loch\f0 sync1=sync1<<3; 
\par \hich\af0\dbch\af17\loch\f0 syncmask=8'b11111000; 
\par }\pard \s31\qj \fi2835\li0\ri0\nowidctlpar\aspalpha\aspnum\faroman\rin0\lin0\itap0 {\f0 \hich\af0\dbch\af17\loch\f0 end 
\par }\pard \s31\qj \li0\ri0\nowidctlpar\aspalpha\aspnum\faroman\rin0\lin0\itap0 {\f0 \hich\af0\dbch\af17\loch\f0  
\par }\pard \s31\qj \fi425\li2125\ri0\nowidctlpar\aspalpha\aspnum\faroman\rin0\lin2125\itap0 {\f0 \hich\af0\dbch\af17\loch\f0 1: 
\par }\pard \s31\qj \fi425\li2550\ri0\nowidctlpar\aspalpha\aspnum\faroman\rin0\lin2550\itap0 {\f0 \hich\af0\dbch\af17\loch\f0 begin 
\par }\pard \s31\qj \fi425\li2975\ri0\nowidctlpar\aspalpha\aspnum\faroman\rin0\lin2975\itap0 {\f0 \hich\af0\dbch\af17\loch\f0 sync1=sync1<< 2; 
\par \hich\af0\dbch\af17\loch\f0 syncmask=8'b11111110; 
\par }\pard \s31\qj \fi425\li2550\ri0\nowidctlpar\aspalpha\aspnum\faroman\rin0\lin2550\itap0 {\f0 \hich\af0\dbch\af17\loch\f0 end 
\par }\pard \s31\qj \li0\ri0\nowidctlpar\aspalpha\aspnum\faroman\rin0\lin0\itap0 {\f0 \hich\af0\dbch\af17\loch\f0  
\par }\pard \s31\qj \fi2520\li0\ri0\nowidctlpar\aspalpha\aspnum\faroman\rin0\lin0\itap0 {\f0 \hich\af0\dbch\af17\loch\f0 2: 
\par }\pard \s31\qj \fi2940\li0\ri0\nowidctlpar\aspalpha\aspnum\faroman\rin0\lin0\itap0 {\f0 \hich\af0\dbch\af17\loch\f0 begin 
\par }\pard \s31\qj \fi2940\li460\ri0\nowidctlpar\aspalpha\aspnum\faroman\rin0\lin460\itap0 {\f0 \hich\af0\dbch\af17\loch\f0 sync1=sync1<< 1; 
\par \hich\af0\dbch\af17\loch\f0 syncmas\hich\af0\dbch\af17\loch\f0 k=8'b11111110; 
\par }\pard \s31\qj \fi2520\li420\ri0\nowidctlpar\aspalpha\aspnum\faroman\rin0\lin420\itap0 {\f0 \hich\af0\dbch\af17\loch\f0 end 
\par }\pard \s31\qj \fi425\li2125\ri0\nowidctlpar\aspalpha\aspnum\faroman\rin0\lin2125\itap0 {\f0 \hich\af0\dbch\af17\loch\f0 3: 
\par }\pard \s31\qj \fi425\li2550\ri0\nowidctlpar\aspalpha\aspnum\faroman\rin0\lin2550\itap0 {\f0 \hich\af0\dbch\af17\loch\f0 syncmask=8'b11111111; 
\par }\pard \s31\qj \fi425\li1700\ri0\nowidctlpar\aspalpha\aspnum\faroman\rin0\lin1700\itap0 {\f0 \hich\af0\dbch\af17\loch\f0 endcase 
\par }\pard \s31\qj \li0\ri0\nowidctlpar\aspalpha\aspnum\faroman\rin0\lin0\itap0 {\f0 \hich\af0\dbch\af17\loch\f0  
\par }\pard \s31\qj \fi425\li1700\ri0\nowidctlpar\aspalpha\aspnum\faroman\rin0\lin1700\itap0 {\f0 \hich\af0\dbch\af17\loch\f0 if(modreg[7]==0) 
\par }\pard \s31\qj \fi425\li2125\ri0\nowidctlpar\aspalpha\aspnum\faroman\rin0\lin2125\itap0 {\f0 \hich\af0\dbch\af17\loch\f0 csel=2;       //if in double sync char mode, get 2 syncs 
\par }\pard \s31\qj \fi425\li1700\ri0\nowidctlpar\aspalpha\aspnum\faroman\rin0\lin1700\itap0 {\f0 \hich\af0\dbch\af17\loch\f0 else 
\par }\pard \s31\qj \fi425\li2125\ri0\nowidctlpar\aspalpha\aspnum\faroman\rin0\lin2125\itap0 {\f0 \hich\af0\dbch\af17\loch\f0 csel=3;      // if in single sync char mode,  get 1 sync 
\par }\pard \s31\qj \fi425\li1275\ri0\nowidctlpar\aspalpha\aspnum\faroman\rin0\lin1275\itap0 {\f0 \hich\af0\dbch\af17\loch\f0 end 
\par }\pard \s31\qj \li0\ri0\nowidctlpar\aspalpha\aspnum\faroman\rin0\lin0\itap0 {\f0 \hich\af0\dbch\af17\loch\f0  
\par }\pard \s31\qj \fi425\li850\ri0\nowidctlpar\aspalpha\aspnum\faroman\rin0\lin850\itap0 {\f0 \hich\af0\dbch\af17\loch\f0 2:            //case 2: 2nd SYNC CHAR - SYNC MODE 
\par }\pard \s31\qj \fi425\li1275\ri0\nowidctlpar\aspalpha\aspnum\faroman\rin0\lin1275\itap0 {\f0 \hich\af0\dbch\af17\loch\f0 begin 
\par }\pard \s31\qj \fi425\li1700\ri0\nowidctlpar\aspalpha\aspnum\faroman\rin0\lin1700\itap0 {\f0 \hich\af0\dbch\af17\loch\f0 sync2=dbus; 
\par }\pard \s31\qj \fi425\li1275\ri0\nowidctlpar\aspalpha\aspnum\faroman\rin0\lin1275\itap0 {\f0 \hich\af0\dbch\af17\loch\f0 case (modreg[3:2]) 
\par }\pard \s31\qj \fi425\li1700\ri0\nowidctlpar\aspalpha\aspnum\faroman\rin0\lin1700\itap0 {\f0 \hich\af0\dbch\af17\loch\f0 0: sync2=sync2<< 3; 
\par }\pard \s31\qj \li2125\ri0\nowidctlpar\aspalpha\aspnum\faroman\rin0\lin2125\itap0 {\f0 \hich\af0\dbch\af17\loch\f0 1: sync2=sync2<< 2; 
\par }\pard \s31\qj \fi425\li1700\ri0\nowidctlpar\aspalpha\aspnum\faroman\rin0\lin1700\itap0 {\f0 \hich\af0\dbch\af17\loch\f0 2: sync2=sync2<< 1; 
\par }\pard \s31\qj \fi425\li1275\ri0\nowidctlpar\aspalpha\aspnum\faroman\rin0\lin1275\itap0 {\f0 \hich\af0\dbch\af17\loch\f0 endcase 
\par }\pard \s31\qj \fi425\li1700\ri0\nowidctlpar\aspalpha\aspnum\faroman\rin0\lin1700\itap0 {\f0 \hich\af0\dbch\af17\loch\f0 csel=3; 
\par }\pard \s31\qj \fi425\li1275\ri0\nowidctlpar\aspalpha\aspnum\faroman\rin0\lin1275\itap0 {\f0 \hich\af0\dbch\af17\loch\f0 end 
\par }\pard \s31\qj \li0\ri0\nowidctlpar\aspalpha\aspnum\faroman\rin0\lin0\itap0 {\f0 \hich\af0\dbch\af17\loch\f0  
\par }\pard \s31\qj \fi425\li850\ri0\nowidctlpar\aspalpha\aspnum\faroman\rin0\lin850\itap0 {\f0 \hich\af0\dbch\af17\loch\f0 3:                   // case 3: COMMAND INSTRUCTION - SYNC/ASYNC MODE 
\par }\pard \s31\qj \fi425\li1275\ri0\nowidctlpar\aspalpha\aspnum\faroman\rin0\lin1275\itap0 {\f0 \hich\af0\dbch\af17\loch\f0 begin 
\par }\pard \s31\qj \li2125\ri0\nowidctlpar\aspalpha\aspnum\faroman\rin0\lin2125\itap0 {\f0 \hich\af0\dbch\af17\loch\f0 status[0]=0;         // Trick:force delay txtdy p\hich\af0\dbch\af17\loch\f0 in if command[0] 
\par }\pard \s31\qj \fi425\li1700\ri0\nowidctlpar\aspalpha\aspnum\faroman\rin0\lin1700\itap0 {\f0 \hich\af0\dbch\af17\loch\f0 command=dbus; 
\par \hich\af0\dbch\af17\loch\f0 dtr_= ! command[1]; 
\par 
\par }\pard \s31\qj \fi425\li1275\ri0\nowidctlpar\aspalpha\aspnum\faroman\rin0\lin1275\itap0 {\f0 \hich\af0\dbch\af17\loch\f0 if(command[3])        //  if send break command 
\par }\pard \s31\qj \li0\ri0\nowidctlpar\aspalpha\aspnum\faroman\rin0\lin0\itap0 {\f0 \hich\af0\dbch\af17\loch\f0   \tab \tab \tab \tab \tab assign txd=0;   // set txd=0  (ignores/override ***** only 
\par \hich\af0\dbch\af17\loch\f0                       \tab \tab \tab \tab // candence synerngy support assign,deassign  
\par }\pard \s31\qj \fi425\li1275\ri0\nowidctlpar\aspalpha\aspnum\faroman\rin0\lin1275\itap0 {\f0 \hich\af0\dbch\af17\loch\f0 else        \hich\af0\dbch\af17\loch\f0      // later non-assign assignment 
\par }\pard \s31\qj \li0\ri0\nowidctlpar\aspalpha\aspnum\faroman\rin0\lin0\itap0 {\f0 \hich\af0\dbch\af17\loch\f0   \tab \tab \tab \tab \tab deassign txd; 
\par 
\par }\pard \s31\qj \fi425\li1275\ri0\nowidctlpar\aspalpha\aspnum\faroman\rin0\lin1275\itap0 {\f0 \hich\af0\dbch\af17\loch\f0 if(command[4])  
\par }\pard \s31\qj \fi425\li1700\ri0\nowidctlpar\aspalpha\aspnum\faroman\rin0\lin1700\itap0 {\f0 \hich\af0\dbch\af17\loch\f0 status[5:3]=0;  //Clear Frame /Parity/Overrun 
\par \hich\af0\dbch\af17\loch\f0 rts_= ! command[5]; 
\par 
\par }\pard \s31\qj \fi425\li1275\ri0\nowidctlpar\aspalpha\aspnum\faroman\rin0\lin1275\itap0 {\f0 \hich\af0\dbch\af17\loch\f0 if(command[6]) -> resete;           //internal reset 
\par }\pard \s31\qj \li0\ri0\nowidctlpar\aspalpha\aspnum\faroman\rin0\lin0\itap0 {\f0 \hich\af0\dbch\af17\loch\f0  
\par }\pard \s31\qj \fi425\li1275\ri0\nowidctlpar\aspalpha\aspnum\faroman\rin0\lin1275\itap0 {\f0 \hich\af0\dbch\af17\loch\f0 if(modreg[1:0]==0  &&  command[7]) 
\par }\pard \s31\qj \fi425\li1700\ri0\nowidctlpar\aspalpha\aspnum\faroman\rin0\lin1700\itap0 {\f0 \hich\af0\dbch\af17\loch\f0 begin          
\par \hich\af0\dbch\af17\loch\f0   \hich\af0\dbch\af17\loch\f0        // if sync mode and enter hunt 
\par }\pard \s31\qj \fi425\li2125\ri0\nowidctlpar\aspalpha\aspnum\faroman\rin0\lin2125\itap0 {\f0 \hich\af0\dbch\af17\loch\f0 disable syn_receive_internal; 
\par \hich\af0\dbch\af17\loch\f0      // disasble the sync receiver 
\par \hich\af0\dbch\af17\loch\f0 disable syn_receive_external; 
\par }\pard \s31\qj \li0\ri0\nowidctlpar\aspalpha\aspnum\faroman\rin0\lin0\itap0 {\f0 \hich\af0\dbch\af17\loch\f0  
\par }\pard \s31\qj \fi425\li2125\ri0\nowidctlpar\aspalpha\aspnum\faroman\rin0\lin2125\itap0 {\f0 \hich\af0\dbch\af17\loch\f0 receivebuf=8'hff;      //  reset receive buffer 1's 
\par \hich\af0\dbch\af17\loch\f0 -> start_receiver_e;   //  restart sync mode receiver 
\par }\pard \s31\qj \fi425\li1700\ri0\nowidctlpar\aspalpha\aspnum\faroman\rin0\lin1700\itap0 {\f0 \hich\af0\dbch\af17\loch\f0 end 
\par }\pard \s31\qj \li0\ri0\nowidctlpar\aspalpha\aspnum\faroman\rin0\lin0\itap0 {\f0 \hich\af0\dbch\af17\loch\f0  
\par }\pard \s31\qj \fi425\li1700\ri0\nowidctlpar\aspalpha\aspnum\faroman\rin0\lin1700\itap0 {\f0 \hich\af0\dbch\af17\loch\f0 if\hich\af0\dbch\af17\loch\f0 (receive_in_progress==0) 
\par \hich\af0\dbch\af17\loch\f0 -> start_receiver_e; 
\par }\pard \s31\qj \li0\ri0\nowidctlpar\aspalpha\aspnum\faroman\rin0\lin0\itap0 {\f0 \hich\af0\dbch\af17\loch\f0  
\par }\pard \s31\qj \fi425\li1700\ri0\nowidctlpar\aspalpha\aspnum\faroman\rin0\lin1700\itap0 {\f0 \hich\af0\dbch\af17\loch\f0 repeat(`TTXRDY)  @(posedge clk); 
\par \hich\af0\dbch\af17\loch\f0 status[0]=1; 
\par }\pard \s31\qj \fi425\li850\ri0\nowidctlpar\aspalpha\aspnum\faroman\rin0\lin850\itap0 {\f0 \hich\af0\dbch\af17\loch\f0 end 
\par }\pard \s31\qj \fi425\li425\ri0\nowidctlpar\aspalpha\aspnum\faroman\rin0\lin425\itap0 {\f0 \hich\af0\dbch\af17\loch\f0 endcase 
\par }\pard \s31\qj \li425\ri0\nowidctlpar\aspalpha\aspnum\faroman\rin0\lin425\itap0 {\f0 \hich\af0\dbch\af17\loch\f0 end 
\par }\pard \s31\qj \li0\ri0\nowidctlpar\aspalpha\aspnum\faroman\rin0\lin0\itap0 {\f0 \hich\af0\dbch\af17\loch\f0 end 
\par \hich\af0\dbch\af17\loch\f0  
\par 
\par \hich\af0\dbch\af17\loch\f0 reg [7:0] serial_data; 
\par \hich\af0\dbch\af17\loch\f0 reg parity_bit; 
\par \hich\af0\dbch\af17\loch\f0  
\par \hich\af0\dbch\af17\loch\f0 always wait (tdata_out_full==1) 
\par \hich\af0\dbch\af17\loch\f0 begin :trans1 
\par }\pard \s31\qj \fi425\li0\ri0\nowidctlpar\aspalpha\aspnum\faroman\rin0\lin0\itap0 {\f0 \hich\af0\dbch\af17\loch\f0 if(dflags[1]) 
\par }\pard \s31\qj \fi425\li425\ri0\nowidctlpar\aspalpha\aspnum\faroman\rin0\lin425\itap0 {\f0 \hich\af0\dbch\af17\loch\f0 $display("I8251A (%h) at \hich\af0\dbch\af17\loch\f0 %d: transmitting data: %b", 
\par }\pard \s31\qj \fi425\li2975\ri0\nowidctlpar\aspalpha\aspnum\faroman\rin0\lin2975\itap0 {\f0 \hich\af0\dbch\af17\loch\f0 instance_id,$time, tdata_out); 
\par }\pard \s31\qj \li0\ri0\nowidctlpar\aspalpha\aspnum\faroman\rin0\lin0\itap0 {\f0 \hich\af0\dbch\af17\loch\f0  
\par }\pard \s31\qj \fi425\li0\ri0\nowidctlpar\aspalpha\aspnum\faroman\rin0\lin0\itap0 {\f0 \hich\af0\dbch\af17\loch\f0 if(tdata_out_wait)             \tab // if the data arrived any old time  
\par }\pard \s31\qj \fi425\li425\ri0\nowidctlpar\aspalpha\aspnum\faroman\rin0\lin425\itap0 {\f0 \hich\af0\dbch\af17\loch\f0 @(negedge txc_);            // wait for a negedge on txc_ 
\par }\pard \s31\qj \fi425\li3400\ri0\nowidctlpar\aspalpha\aspnum\faroman\rin0\lin3400\itap0 {\f0 \hich\af0\dbch\af17\loch\f0 // but if a stop bit was just sent 
\par }\pard \s31\qj \li3825\ri0\nowidctlpar\aspalpha\aspnum\faroman\rin0\lin3825\itap0 {\f0 \hich\af0\dbch\af17\loch\f0 // do not wait 
\par }\pard \s31\qj \fi425\li850\ri0\nowidctlpar\aspalpha\aspnum\faroman\rin0\lin850\itap0 {\f0 \hich\af0\dbch\af17\loch\f0 serial_data=\hich\af0\dbch\af17\loch\f0 tdata_out; 
\par }\pard \s31\qj \li0\ri0\nowidctlpar\aspalpha\aspnum\faroman\rin0\lin0\itap0 {\f0 \hich\af0\dbch\af17\loch\f0  
\par }\pard \s31\qj \fi425\li425\ri0\nowidctlpar\aspalpha\aspnum\faroman\rin0\lin425\itap0 {\f0 \hich\af0\dbch\af17\loch\f0 if (tstoptotal  != 0)         // if async mode ... 
\par }\pard \s31\qj \fi425\li850\ri0\nowidctlpar\aspalpha\aspnum\faroman\rin0\lin850\itap0 {\f0 \hich\af0\dbch\af17\loch\f0 begin 
\par }\pard \s31\qj \fi425\li1275\ri0\nowidctlpar\aspalpha\aspnum\faroman\rin0\lin1275\itap0 {\f0 \hich\af0\dbch\af17\loch\f0 txd=0;                       //then send a start bit 1st   
\par \hich\af0\dbch\af17\loch\f0 repeat(baudmx) @(negedge txc_); 
\par }\pard \s31\qj \fi425\li850\ri0\nowidctlpar\aspalpha\aspnum\faroman\rin0\lin850\itap0 {\f0 \hich\af0\dbch\af17\loch\f0 end 
\par }\pard \s31\qj \li0\ri0\nowidctlpar\aspalpha\aspnum\faroman\rin0\lin0\itap0 {\f0 \hich\af0\dbch\af17\loch\f0  
\par }\pard \s31\qj \fi425\li425\ri0\nowidctlpar\aspalpha\aspnum\faroman\rin0\lin425\itap0 {\f0 \hich\af0\dbch\af17\loch\f0 repeat(databits)   //send all start,databits 
\par }\pard \s31\qj \fi425\li850\ri0\nowidctlpar\aspalpha\aspnum\faroman\rin0\lin850\itap0 {\f0 \hich\af0\dbch\af17\loch\f0 begin 
\par }\pard \s31\qj \fi425\li1275\ri0\nowidctlpar\aspalpha\aspnum\faroman\rin0\lin1275\itap0 {\f0 \hich\af0\dbch\af17\loch\f0 txd=serial_data[0]; 
\par \hich\af0\dbch\af17\loch\f0 repeat(ba\hich\af0\dbch\af17\loch\f0 udmx)  @(negedge txc_); 
\par \hich\af0\dbch\af17\loch\f0 serial_data=serial_data>>1; 
\par }\pard \s31\qj \fi425\li850\ri0\nowidctlpar\aspalpha\aspnum\faroman\rin0\lin850\itap0 {\f0 \hich\af0\dbch\af17\loch\f0 end 
\par }\pard \s31\qj \li0\ri0\nowidctlpar\aspalpha\aspnum\faroman\rin0\lin0\itap0 {\f0 \hich\af0\dbch\af17\loch\f0  
\par }\pard \s31\qj \fi425\li425\ri0\nowidctlpar\aspalpha\aspnum\faroman\rin0\lin425\itap0 {\f0 \hich\af0\dbch\af17\loch\f0 if (modreg [4])              //  if parity is enabled ...
\par }\pard \s31\qj \fi425\li850\ri0\nowidctlpar\aspalpha\aspnum\faroman\rin0\lin850\itap0 {\f0 \hich\af0\dbch\af17\loch\f0 begin 
\par }\pard \s31\qj \fi425\li1275\ri0\nowidctlpar\aspalpha\aspnum\faroman\rin0\lin1275\itap0 {\f0 \hich\af0\dbch\af17\loch\f0 parity_bit=^(tdata_out & data_mask); 
\par \hich\af0\dbch\af17\loch\f0 if(modreg[5]==0) parity_bit= ~parity_bit;  // odd parity 
\par }\pard \s31\qj \li0\ri0\nowidctlpar\aspalpha\aspnum\faroman\rin0\lin0\itap0 {\f0 \hich\af0\dbch\af17\loch\f0  
\par }\pard \s31\qj \fi425\li1275\ri0\nowidctlpar\aspalpha\aspnum\faroman\rin0\lin1275\itap0 {\f0 \hich\af0\dbch\af17\loch\f0 txd=parity_bit; 
\par \hich\af0\dbch\af17\loch\f0 repeat(baudmx) \hich\af0\dbch\af17\loch\f0  @(negedge txc_);       //then send the parity bit 
\par }\pard \s31\qj \fi425\li850\ri0\nowidctlpar\aspalpha\aspnum\faroman\rin0\lin850\itap0 {\f0 \hich\af0\dbch\af17\loch\f0 end 
\par }\pard \s31\qj \li0\ri0\nowidctlpar\aspalpha\aspnum\faroman\rin0\lin0\itap0 {\f0 \hich\af0\dbch\af17\loch\f0  
\par }\pard \s31\qj \fi425\li0\ri0\nowidctlpar\aspalpha\aspnum\faroman\rin0\lin0\itap0 {\f0 \hich\af0\dbch\af17\loch\f0 if(tstoptotal  != 0)       // if sync mode 
\par }\pard \s31\qj \fi425\li425\ri0\nowidctlpar\aspalpha\aspnum\faroman\rin0\lin425\itap0 {\f0 \hich\af0\dbch\af17\loch\f0 begin 
\par }\pard \s31\qj \fi425\li850\ri0\nowidctlpar\aspalpha\aspnum\faroman\rin0\lin850\itap0 {\f0 \hich\af0\dbch\af17\loch\f0 txd=1;       //then send out the stop bit (s 
\par \hich\af0\dbch\af17\loch\f0 repeat(tstoptotal)    @(negedge txc_); 
\par }\pard \s31\qj \fi425\li425\ri0\nowidctlpar\aspalpha\aspnum\faroman\rin0\lin425\itap0 {\f0 \hich\af0\dbch\af17\loch\f0 end  
\par }\pard \s31\qj \li0\ri0\nowidctlpar\aspalpha\aspnum\faroman\rin0\lin0\itap0 {\f0 \hich\af0\dbch\af17\loch\f0  
\par }\pard \s31\qj \fi425\li425\ri0\nowidctlpar\aspalpha\aspnum\faroman\rin0\lin425\itap0 {\f0 \hich\af0\dbch\af17\loch\f0 tdata_out_full=0;  // block this routine until data/\hich\af0\dbch\af17\loch\f0 sync char to be sent 
\par }\pard \s31\qj \li0\ri0\nowidctlpar\aspalpha\aspnum\faroman\rin0\lin0\itap0 {\f0 \hich\af0\dbch\af17\loch\f0                    // is immediately transferred to tdata_out. 
\par \hich\af0\dbch\af17\loch\f0   
\par }\pard \s31\qj \fi425\li425\ri0\nowidctlpar\aspalpha\aspnum\faroman\rin0\lin425\itap0 {\f0 \hich\af0\dbch\af17\loch\f0 ->txende;         //decide what data should be sent (data/sync/stop bit) 
\par }\pard \s31\qj \li0\ri0\nowidctlpar\aspalpha\aspnum\faroman\rin0\lin0\itap0 {\f0 \hich\af0\dbch\af17\loch\f0 end 
\par \hich\af0\dbch\af17\loch\f0  
\par \hich\af0\dbch\af17\loch\f0 event transmit_held_data_e,transmitter_idle_e; 
\par \hich\af0\dbch\af17\loch\f0  
\par \hich\af0\dbch\af17\loch\f0 always @txende \tab       //end of trans\hich\af0\dbch\af17\loch\f0 mitted data/sync character 
\par \hich\af0\dbch\af17\loch\f0 begin :trans2 
\par }\pard \s31\qj \fi425\li425\ri0\nowidctlpar\aspalpha\aspnum\faroman\rin0\lin425\itap0 {\f0 \hich\af0\dbch\af17\loch\f0 case (command[0] & ~cts_) 
\par \hich\af0\dbch\af17\loch\f0 0:\tab                    //if its is not now cts 
\par }\pard \s31\qj \li0\ri0\nowidctlpar\aspalpha\aspnum\faroman\rin0\lin0\itap0 {\f0 \tab \tab \hich\af0\dbch\af17\loch\f0                //but data was received while it was c 
\par }\pard \s31\qj \fi425\li850\ri0\nowidctlpar\aspalpha\aspnum\faroman\rin0\lin850\itap0 {\f0 \hich\af0\dbch\af17\loch\f0 if (tdata_hold_full && tdata_hold_cts) 
\par }\pard \s31\qj \fi425\li1275\ri0\nowidctlpar\aspalpha\aspnum\faroman\rin0\lin1275\itap0 {\f0 \hich\af0\dbch\af17\loch\f0 -> transmit_held_data_e;        // then se\hich\af0\dbch\af17\loch\f0 nd the data char 
\par }\pard \s31\qj \fi425\li850\ri0\nowidctlpar\aspalpha\aspnum\faroman\rin0\lin850\itap0 {\f0 \hich\af0\dbch\af17\loch\f0 else  
\par }\pard \s31\qj \fi425\li1275\ri0\nowidctlpar\aspalpha\aspnum\faroman\rin0\lin1275\itap0 {\f0 \hich\af0\dbch\af17\loch\f0 ->transmitter_idle_e;   //else send sync char(s) or 1 stop bit 
\par }\pard \s31\qj \li0\ri0\nowidctlpar\aspalpha\aspnum\faroman\rin0\lin0\itap0 {\f0 \hich\af0\dbch\af17\loch\f0  
\par }\pard \s31\qj \fi425\li425\ri0\nowidctlpar\aspalpha\aspnum\faroman\rin0\lin425\itap0 {\f0 \hich\af0\dbch\af17\loch\f0 1:\tab \tab //if its is now cts 
\par }\pard \s31\qj \fi425\li850\ri0\nowidctlpar\aspalpha\aspnum\faroman\rin0\lin850\itap0 {\f0 \hich\af0\dbch\af17\loch\f0 if (tdata_hold_full) // if a character has been received  
\par }\pard \s31\qj \fi425\li2975\ri0\nowidctlpar\aspalpha\aspnum\faroman\rin0\lin2975\itap0 {\f0 \hich\af0\dbch\af17\loch\f0 //but now yet ransmitted ... 
\par }\pard \s31\qj \fi425\li1275\ri0\nowidctlpar\aspalpha\aspnum\faroman\rin0\lin1275\itap0 {\f0 \hich\af0\dbch\af17\loch\f0 ->transmit_held_data_e; // then send the data char 
\par }\pard \s31\qj \fi425\li850\ri0\nowidctlpar\aspalpha\aspnum\faroman\rin0\lin850\itap0 {\f0 \hich\af0\dbch\af17\loch\f0 else \tab \tab \tab // else (no character has been received 
\par }\pard \s31\qj \fi425\li1275\ri0\nowidctlpar\aspalpha\aspnum\faroman\rin0\lin1275\itap0 {\f0 \hich\af0\dbch\af17\loch\f0 -> transmitter_idle_e; \tab //\tab send sync char(s) or 1 stop bit 
\par }\pard \s31\qj \fi425\li425\ri0\nowidctlpar\aspalpha\aspnum\faroman\rin0\lin425\itap0 {\f0 \hich\af0\dbch\af17\loch\f0 endcase 
\par }\pard \s31\qj \li0\ri0\nowidctlpar\aspalpha\aspnum\faroman\rin0\lin0\itap0 {\f0 \hich\af0\dbch\af17\loch\f0 end 
\par \hich\af0\dbch\af17\loch\f0  
\par \hich\af0\dbch\af17\loch\f0 always @ (transmitter_idle_e) \tab //if there are no data chars to send ...,
\par \hich\af0\dbch\af17\loch\f0 begin : trans3 
\par \tab \hich\af0\dbch\af17\loch\f0 status[2]=1;\tab                     // mard\hich\af0\dbch\af17\loch\f0  transmitter as being empty 
\par \tab \hich\af0\dbch\af17\loch\f0 txe=1; 
\par }\pard \s31\qj \fi425\li0\ri0\nowidctlpar\aspalpha\aspnum\faroman\rin0\lin0\itap0 {\f0 \hich\af0\dbch\af17\loch\f0 if (tstoptotal !=0 || command[0] ==0 ||cts_ ==1) 
\par }\pard \s31\qj \li0\ri0\nowidctlpar\aspalpha\aspnum\faroman\rin0\lin0\itap0 {\f0 \hich\af0\dbch\af17\loch\f0       // if async mode or after areset or TxEnable = false or cts =false 
\par \tab \tab \hich\af0\dbch\af17\loch\f0 begin 
\par \tab \tab \tab \hich\af0\dbch\af17\loch\f0 if (dflags[1]) 
\par }\pard\plain \qj \li0\ri0\nowidctlpar\aspalpha\aspnum\faroman\rin0\lin0\itap0 \fs21\lang1033\langfe2052\kerning2\loch\af0\hich\af0\dbch\af17\cgrid\langnp1033\langfenp2052 {\tab \tab \tab \tab \hich\af0\dbch\af17\loch\f0 
$display("I8251A (%h) at %d : transmitting data : 1 (stop bit)\hich\af0\dbch\af17\loch\f0 ", 
\par \hich\af0\dbch\af17\loch\f0                                                       instance_id ,$time); 
\par }\pard\plain \s31\qj \li0\ri0\nowidctlpar\aspalpha\aspnum\faroman\rin0\lin0\itap0 \fs21\lang1033\langfe2052\kerning2\loch\af17\hich\af2\dbch\af17\cgrid\langnp1033\langfenp2052 {\f0 \tab \tab \tab \hich\af0\dbch\af17\loch\f0 txd=1;\tab 
      //then  send out 1 stop bit and make any writes  
\par }\pard \s31\qj \fi425\li850\ri0\nowidctlpar\aspalpha\aspnum\faroman\rin0\lin850\itap0 {\f0 \hich\af0\dbch\af17\loch\f0 tdata_out=1;\tab \tab \tab // go to tdata_hold 
\par }\pard \s31\qj \li0\ri0\nowidctlpar\aspalpha\aspnum\faroman\rin0\lin0\itap0 {\f0 \tab \tab \tab \hich\af0\dbch\af17\loch\f0 repeat(baudmx) @(negedge txc_); 
\par \hich\af0\dbch\af17\loch\f0     \tab \tab \tab ->txende; 
\par \hich\af0\dbch\af17\loch\f0    \tab \tab end 
\par }\pard \s31\qj \fi425\li0\ri0\nowidctlpar\aspalpha\aspnum\faroman\rin0\lin0\itap0 {\f0 \hich\af0\dbch\af17\loch\f0 else \tab \tab \tab \tab /\hich\af0\dbch\af17\loch\f0 / if sync mode 
\par \hich\af0\dbch\af17\loch\f0 case (sync_to_transmit) 
\par \hich\af0\dbch\af17\loch\f0 1: 
\par }\pard \s31\qj \li0\ri0\nowidctlpar\aspalpha\aspnum\faroman\rin0\lin0\itap0 {\f0 \tab \tab \hich\af0\dbch\af17\loch\f0 begin 
\par \tab \tab \tab \hich\af0\dbch\af17\loch\f0 tdata_out=sync1 >> (8-databits); 
\par \tab \tab \tab \hich\af0\dbch\af17\loch\f0 tdata_out_wait=0; \tab // without waiting on negedge t 
\par \tab \tab \tab \hich\af0\dbch\af17\loch\f0 tdata_out_full=1; 
\par \tab \tab \tab \hich\af0\dbch\af17\loch\f0 if(modreg[7] == 0)\tab // if double sync mode 
\par \tab \tab \tab \tab \hich\af0\dbch\af17\loch\f0 sync_to_transmit =2;// send 2nd sync a\hich\af0\dbch\af17\loch\f0 fter 1st 
\par \tab \tab \hich\af0\dbch\af17\loch\f0 end 
\par }\pard \s31\qj \fi425\li0\ri0\nowidctlpar\aspalpha\aspnum\faroman\rin0\lin0\itap0 {\f0 \hich\af0\dbch\af17\loch\f0 2: 
\par }\pard \s31\qj \li0\ri0\nowidctlpar\aspalpha\aspnum\faroman\rin0\lin0\itap0 {\f0 \tab \tab \hich\af0\dbch\af17\loch\f0 begin 
\par \tab \tab \tab \hich\af0\dbch\af17\loch\f0 tdata_out =sync2 >> (8-databits); 
\par \tab \tab \tab \hich\af0\dbch\af17\loch\f0 tdata_out_wait =0 ; \tab // without waiting on negedge t 
\par \tab \tab \tab \hich\af0\dbch\af17\loch\f0 tdata_out_full =1 ; 
\par \tab \tab \tab \hich\af0\dbch\af17\loch\f0 sync_to_transmit = 1; \tab //send 1st sync char next 
\par \tab \tab \hich\af0\dbch\af17\loch\f0 end 
\par }\pard \s31\qj \fi425\li0\ri0\nowidctlpar\aspalpha\aspnum\faroman\rin0\lin0\itap0 {\f0 \hich\af0\dbch\af17\loch\f0 endcase 
\par }\pard \s31\qj \li0\ri0\nowidctlpar\aspalpha\aspnum\faroman\rin0\lin0\itap0 {\f0 \hich\af0\dbch\af17\loch\f0 end 
\par \hich\af0\dbch\af17\loch\f0  
\par \hich\af0\dbch\af17\loch\f0 always @ (transmit_held_data_e)\hich\af0\dbch\af17\loch\f0  \tab // if a character has been received *****add ()  
\par \hich\af0\dbch\af17\loch\f0 begin : trans4 
\par \tab \hich\af0\dbch\af17\loch\f0 tdata_out=tdata_hold;\tab  // but not transmitted ... 
\par \tab \hich\af0\dbch\af17\loch\f0 tdata_out_wait = 0;\tab      // then do not wait on negedge txc 
\par \tab \hich\af0\dbch\af17\loch\f0 tdata_out_full = 1;\tab \tab  // and send the char immediately 
\par \tab \hich\af0\dbch\af17\loch\f0 tdata_hold_full \hich\af0\dbch\af17\loch\f0 = 0 ;   
\par \tab \hich\af0\dbch\af17\loch\f0 repeat (`TTXRDY ) @(posedge clk); 
\par \tab \hich\af0\dbch\af17\loch\f0 status[0] = 1;\tab \tab \tab  // and set the txrdy status bit 
\par \hich\af0\dbch\af17\loch\f0 end 
\par \hich\af0\dbch\af17\loch\f0  
\par \hich\af0\dbch\af17\loch\f0 //************************* RECEIVER PORTION OF THE 8251A *******************/ 
\par \hich\af0\dbch\af17\loch\f0 // data is received at leading edge of the clock 
\par \hich\af0\dbch\af17\loch\f0 event break_detect_e,\tab 
\par \tab \hich\af0\dbch\af17\loch\f0   break_delay_e;\tab \tab // 
\par \hich\af0\dbch\af17\loch\f0 event hunt_sync1_e,   \tab //hunt for the 1st sync char 
\par \tab \hich\af0\dbch\af17\loch\f0   hunt_sync2_e,\tab     //hunt for the 2nd sync char (double sync mode) 
\par \tab \hich\af0\dbch\af17\loch\f0   sync_hunted_e, \tab //sync char(s) was found (on abit aligned basis  
\par \tab \hich\af0\dbch\af17\loch\f0   external_syndet_watche; //external sy\hich\af0\dbch\af17\loch\f0 nc mode: whenever syndet pin  
\par \tab \tab \tab \tab \tab \tab \tab \hich\af0\dbch\af17\loch\f0  // goes high, set the syndet status bit 
\par \hich\af0\dbch\af17\loch\f0  
\par \hich\af0\dbch\af17\loch\f0 always @start_receiver_e 
\par \hich\af0\dbch\af17\loch\f0 begin :rcv_blk 
\par \tab \hich\af0\dbch\af17\loch\f0 receive_in_progress = 1; 
\par \tab \hich\af0\dbch\af17\loch\f0 case (modreg[1:0]) 
\par \tab \hich\af0\dbch\af17\loch\f0 2'b00: 
\par \tab \tab \hich\af0\dbch\af17\loch\f0 if (modreg[6] ==0)\tab // if internal syndet mode ... 
\par \tab \tab \hich\af0\dbch\af17\loch\f0 begin 
\par \tab \tab \tab \hich\af0\dbch\af17\loch\f0 if (dflags\hich\af0\dbch\af17\loch\f0 [5]) 
\par \tab \tab \tab \tab \hich\af0\dbch\af17\loch\f0 $display("I8251A (%h) at %d : starting internal sync receive",
\par \tab \tab \tab \tab \hich\af0\dbch\af17\loch\f0 instance_id, $time);
\par \tab \tab \tab \tab \hich\af0\dbch\af17\loch\f0 if (dflags[5] && command[7]) 
\par }\pard \s31\qj \fi-1155\li3255\ri0\nowidctlpar\aspalpha\aspnum\faroman\rin0\lin3255\itap0 {\f0 \hich\af0\dbch\af17\loch\f0 $display("I8251A (%h) at %d : hunting for syncs", instance_id, $time); 
\par }\pard \s31\qj \li0\ri0\nowidctlpar\aspalpha\aspnum\faroman\rin0\lin0\itap0 {\f0 \tab \tab \tab \hich\af0\dbch\af17\loch\f0    if (modreg[7]==1)\tab // if enter hunt mode 
\par \tab \tab \tab \tab \hich\af0\dbch\af17\loch\f0 b\hich\af0\dbch\af17\loch\f0 egin  
\par \tab \tab \tab \tab \tab \hich\af0\dbch\af17\loch\f0 if(dflags[5]) 
\par \tab \tab \tab \tab \tab \tab \hich\af0\dbch\af17\loch\f0 $display("I8251A (%h) at %d :receiver waiting on syndet",
\par \hich\af0\dbch\af17\loch\f0  \tab \tab \tab \tab \tab \tab    instance_id, $time);
\par \tab \tab \tab \tab \tab \hich\af0\dbch\af17\loch\f0 ->hunt_sync1_e;\tab //start search for sync char(s 
\par \tab \tab \tab \tab \tab \hich\af0\dbch\af17\loch\f0 @(posedge syndet); 
\par \tab \tab \tab \tab \tab \hich\af0\dbch\af17\loch\f0 if(dflags[5]) 
\par }\pard \s31\qj \fi-985\li3400\ri0\nowidctlpar\aspalpha\aspnum\faroman\rin0\lin3400\itap0 {\f0 \hich\af0\dbch\af17\loch\f0 $display("I8251A (%h) at %d : receiv\hich\af0\dbch\af17\loch\f0 er DONE waiting on syndet", instance_id, $time); 
\par }\pard \s31\qj \li0\ri0\nowidctlpar\aspalpha\aspnum\faroman\rin0\lin0\itap0 {\f0 \tab \tab \tab \tab \hich\af0\dbch\af17\loch\f0 end 
\par \tab \tab \tab \tab \hich\af0\dbch\af17\loch\f0 syn_receive_internal;\tab //start sync mode receiver 
\par \tab \tab \hich\af0\dbch\af17\loch\f0 end 
\par \tab \tab \hich\af0\dbch\af17\loch\f0 else 
\par \tab \tab \hich\af0\dbch\af17\loch\f0 begin 
\par \tab \tab \tab \hich\af0\dbch\af17\loch\f0 if(dflags[5]) 
\par \tab \tab \tab \tab \hich\af0\dbch\af17\loch\f0 $display("I8251A (%h) at %d : starting external sync receive", instance_id, $time); 
\par \tab \tab \tab \hich\af0\dbch\af17\loch\f0 if(dflags\hich\af0\dbch\af17\loch\f0 [5] && command[7]) 
\par \tab \tab \tab \tab \hich\af0\dbch\af17\loch\f0 $display("I8251A (%h) at %d : hunting for syncs",  
\par \hich\af0\dbch\af17\loch\f0 instance_id, $time);  
\par \tab \tab \tab \hich\af0\dbch\af17\loch\f0 ->external_syndet_watche;\tab // whenever syndet pin goes to 1 
\par \tab \tab \tab \tab \tab \tab \tab \tab \tab \tab \tab \tab \hich\af0\dbch\af17\loch\f0 // set syndet status bit 
\par \tab \tab \tab \hich\af0\dbch\af17\loch\f0 if (command[7]==1) 
\par \tab \tab \tab \hich\af0\dbch\af17\loch\f0 begin:external_syn_hunt_blk 
\par \tab \tab \tab \tab \hich\af0\dbch\af17\loch\f0 fork 
\par \tab \tab \tab \tab \tab \hich\af0\dbch\af17\loch\f0 syn_receive_external;\tab // assemble chars while waiting 
\par \tab \tab \tab \tab \tab \hich\af0\dbch\af17\loch\f0 @(posedge syndet) \tab // after rising edge of syndet 
\par \tab \tab \tab \tab \tab \hich\af0\dbch\af17\loch\f0 @(negedge syndet)\tab \tab // wait for falling edge 
\par \tab \tab \tab \tab \tab \tab \tab \tab \tab \tab \tab \tab \hich\af0\dbch\af17\loch\f0 // begore starting char assemble 
\par \tab \tab \tab \tab \tab \hich\af0\dbch\af17\loch\f0 disable external_syn_hunt_blk;\hich\af0\dbch\af17\loch\f0  
\par \tab \tab \tab \tab \hich\af0\dbch\af17\loch\f0 join 
\par \tab \tab \tab \hich\af0\dbch\af17\loch\f0 end 
\par \hich\af0\dbch\af17\loch\f0  
\par \tab \tab \hich\af0\dbch\af17\loch\f0 syn_receive_external;\tab // start external sync mode receiving 
\par \tab \tab \hich\af0\dbch\af17\loch\f0 end 
\par \tab \hich\af0\dbch\af17\loch\f0 default:\tab // if async mode ... 
\par \tab \tab \hich\af0\dbch\af17\loch\f0 begin 
\par \tab \tab \tab \hich\af0\dbch\af17\loch\f0 if(dflags[5]) 
\par \tab \tab \tab \tab \hich\af0\dbch\af17\loch\f0 $display("I8251A (%h) at %d : starting asynchronous receiver", instance_id, $time);
\par \tab \tab \tab \hich\af0\dbch\af17\loch\f0 ->break_detect\hich\af0\dbch\af17\loch\f0 _e;\tab // start check for rcd=0 too long 
\par \tab \tab \tab \hich\af0\dbch\af17\loch\f0 asyn_receive;\tab // and start async mode receiver 
\par \tab \tab \hich\af0\dbch\af17\loch\f0 end 
\par \tab \hich\af0\dbch\af17\loch\f0 endcase 
\par \hich\af0\dbch\af17\loch\f0 end 
\par \hich\af0\dbch\af17\loch\f0  
\par \tab \hich\af0\dbch\af17\loch\f0 /***** EXTERNAL SYNCHRONOUS MODE RECEIVE *****/ 
\par \hich\af0\dbch\af17\loch\f0 task syn_receive_rexternal; 
\par \hich\af0\dbch\af17\loch\f0 forever 
\par \tab \hich\af0\dbch\af17\loch\f0 begin 
\par \tab \tab \hich\af0\dbch\af17\loch\f0 repeat(databits)\tab //Whether in hunt mode or n\hich\af0\dbch\af17\loch\f0 ot,assemble a character 
\par \tab \tab \hich\af0\dbch\af17\loch\f0 begin 
\par \tab \tab \tab \hich\af0\dbch\af17\loch\f0 @(posedge rxc_) 
\par \tab \tab \tab \hich\af0\dbch\af17\loch\f0 receivebuf=\{rcd, receivebuf[7:1]\}; 
\par \tab \tab \hich\af0\dbch\af17\loch\f0 end 
\par \tab \tab \hich\af0\dbch\af17\loch\f0 get_and_check_parity;\tab //receive and check parity bit, if any 
\par \tab \tab \hich\af0\dbch\af17\loch\f0 mark_char_received;\tab //set rxrdy line, if enalbed 
\par \tab \hich\af0\dbch\af17\loch\f0 end 
\par \hich\af0\dbch\af17\loch\f0 endtask 
\par \hich\af0\dbch\af17\loch\f0  
\par \hich\af0\dbch\af17\loch\f0 always @(external_synde\hich\af0\dbch\af17\loch\f0 t_watche)  
\par \tab \hich\af0\dbch\af17\loch\f0 @(posedge rxc_) 
\par \tab \tab \hich\af0\dbch\af17\loch\f0 status[6]=1; 
\par \tab \tab \tab \hich\af0\dbch\af17\loch\f0 /****INTERNAL SYNCHRONOUS MODE RECEIVE ***/ 
\par \tab \tab \tab \hich\af0\dbch\af17\loch\f0 /*   Hunt for the sync char(s)\tab \tab \tab   */ 
\par \tab \tab \tab \hich\af0\dbch\af17\loch\f0 /*\tab  (if in synchronous internal sync detect mode) */ 
\par \tab \tab \tab \hich\af0\dbch\af17\loch\f0 /* Syndet is set high when the sync(s) are found */ 
\par \hich\af0\dbch\af17\loch\f0  
\par \hich\af0\dbch\af17\loch\f0 alway\hich\af0\dbch\af17\loch\f0 s @ (hunt_sysnc1_e)\tab //search for 1st sync char in the data stream 
\par \hich\af0\dbch\af17\loch\f0 begin :sync_hunt_blk 
\par \tab \hich\af0\dbch\af17\loch\f0 while(!(((receivebuf ^ sync1) & syncmask) === 8'b0000_0000)) 
\par \tab \hich\af0\dbch\af17\loch\f0 begin 
\par \tab \tab \hich\af0\dbch\af17\loch\f0 @(posedge rxc_) 
\par \tab \tab \hich\af0\dbch\af17\loch\f0 receivebuf = \{rcd, receivebuf[7:1]\}; 
\par \tab \hich\af0\dbch\af17\loch\f0 end 
\par \tab \hich\af0\dbch\af17\loch\f0 if ( modreg[7]==0) \tab // if doub\hich\af0\dbch\af17\loch\f0 le sync mod 
\par \tab \tab \hich\af0\dbch\af17\loch\f0 ->hunt_sync2_e;\tab //check for 2nd sync char directly agter 1 
\par \tab \hich\af0\dbch\af17\loch\f0 else 
\par \tab \tab \hich\af0\dbch\af17\loch\f0 -> sync_hunted_e;\tab // if single sync mode , sync hunt is complete 
\par \hich\af0\dbch\af17\loch\f0 end 
\par \hich\af0\dbch\af17\loch\f0 always @ (hunt_sync2_e) \tab // find the second synchronous character 
\par \hich\af0\dbch\af17\loch\f0 begin : double_sync_hunt_blk 
\par \tab \hich\af0\dbch\af17\loch\f0 rep\hich\af0\dbch\af17\loch\f0 eat(databits) 
\par \tab \hich\af0\dbch\af17\loch\f0 begin 
\par \tab \tab \hich\af0\dbch\af17\loch\f0 @(posedge rxc_) 
\par \tab \tab \hich\af0\dbch\af17\loch\f0 receivebuf=\{rcd,receivebuf[7:1]\}; 
\par \tab \hich\af0\dbch\af17\loch\f0 end 
\par \tab \hich\af0\dbch\af17\loch\f0 if((receivebuf ^ sync2)& syncmask===8'b0000_0000) 
\par \tab \tab \hich\af0\dbch\af17\loch\f0 ->sync_hunted_e; // if sync2 followed syn1,sync hunt is complete 
\par \tab \hich\af0\dbch\af17\loch\f0 else 
\par \tab \tab \hich\af0\dbch\af17\loch\f0 ->hunt_sync1_e;\tab //else hunt for sync1 agai\hich\af0\dbch\af17\loch\f0 n 
\par \hich\af0\dbch\af17\loch\f0  
\par \tab \hich\af0\dbch\af17\loch\f0 // Note : the data stream [sync1 sync1 sync2] will have sync detected. 
\par \tab \hich\af0\dbch\af17\loch\f0 // Suppose sync1=11001100: 
\par \tab \hich\af0\dbch\af17\loch\f0 // Then [1100 1100 1100 sync2]will NOT be detected . 
\par \tab \hich\af0\dbch\af17\loch\f0 // In general : never let a suffix of sync1 also be a prefix of sync1. 
\par \hich\af0\dbch\af17\loch\f0 end 
\par \hich\af0\dbch\af17\loch\f0  
\par \hich\af0\dbch\af17\loch\f0 always @ (sync\hich\af0\dbch\af17\loch\f0 _hunted_e) 
\par \hich\af0\dbch\af17\loch\f0 begin :parity_sync_hunt_blk 
\par \tab \hich\af0\dbch\af17\loch\f0 get_and_check_parity; 
\par \tab \hich\af0\dbch\af17\loch\f0 status[6]=1;\tab //set syndet status bit (sync chars detected ) 
\par \hich\af0\dbch\af17\loch\f0 end 
\par \hich\af0\dbch\af17\loch\f0  
\par \hich\af0\dbch\af17\loch\f0 task syn_receive_internal; 
\par \hich\af0\dbch\af17\loch\f0 forever 
\par \hich\af0\dbch\af17\loch\f0 begin 
\par \tab \hich\af0\dbch\af17\loch\f0 repeat(databits)\tab //no longer in hunt mode so read entire chars and  
\par \tab \hich\af0\dbch\af17\loch\f0 begin  \hich\af0\dbch\af17\loch\f0            // then look for syncs (instead of on bit boundaries) 
\par \tab \tab \hich\af0\dbch\af17\loch\f0 @(posedge rxc_) 
\par \tab \tab \hich\af0\dbch\af17\loch\f0 receivebuf=\{rcd,receivebuf[7:1]\}; 
\par \tab \hich\af0\dbch\af17\loch\f0 end 
\par \tab \hich\af0\dbch\af17\loch\f0 case (sync_to_receive)  
\par \tab \hich\af0\dbch\af17\loch\f0 2:\tab \tab \tab // if looking for 2nd sync char ...  
\par \tab \hich\af0\dbch\af17\loch\f0 begin 
\par \tab \tab \hich\af0\dbch\af17\loch\f0 if(((receivebuf ^ sync2) & syncmask)===0) 
\par \tab \tab \hich\af0\dbch\af17\loch\f0 beg\hich\af0\dbch\af17\loch\f0 in \tab //... and 2nd sync char is found  
\par \tab \tab \tab \hich\af0\dbch\af17\loch\f0 sync_to_receive =1;\tab //then look ofr 1st sync (or data) 
\par \tab \tab \tab \hich\af0\dbch\af17\loch\f0 status[6]=1;\tab \tab // and mark sync detected 
\par \tab \tab \hich\af0\dbch\af17\loch\f0 end 
\par \tab \tab \hich\af0\dbch\af17\loch\f0 else if (((receivebuf ^ sync1) & syncmask)===0) 
\par \tab \tab \hich\af0\dbch\af17\loch\f0 begin \tab //... and 1st sync char is found  
\par \tab \tab \tab \hich\af0\dbch\af17\loch\f0 sync_to_r\hich\af0\dbch\af17\loch\f0 eceive = 2;\tab //then look for 2nd sync char 
\par \tab \tab \hich\af0\dbch\af17\loch\f0 end 
\par \tab \tab \hich\af0\dbch\af17\loch\f0 end 
\par \tab \hich\af0\dbch\af17\loch\f0 1: 
\par \tab \hich\af0\dbch\af17\loch\f0 begin 
\par \tab \tab \hich\af0\dbch\af17\loch\f0 if ((( receivebuf ^ sync1) & syncmask) ===0) // ... and 1st sync is found  
\par \tab \tab \hich\af0\dbch\af17\loch\f0 begin 
\par \tab \tab \tab \hich\af0\dbch\af17\loch\f0 if(modreg[7]==0)\tab //if doulbe sync mode 
\par \tab \tab \tab \tab \hich\af0\dbch\af17\loch\f0 sync_to_receive =2; \tab // look for 2nd sync to foll 
\par \tab \tab \tab \hich\af0\dbch\af17\loch\f0 else 
\par \tab \tab \tab \tab \hich\af0\dbch\af17\loch\f0 status[6]=1; \tab //else look for 1st or data and mark sync detected  
\par \tab \tab \hich\af0\dbch\af17\loch\f0 end 
\par \tab \tab \hich\af0\dbch\af17\loch\f0 else;\tab //and data was found , do nothing 
\par \tab \hich\af0\dbch\af17\loch\f0 end 
\par \tab \hich\af0\dbch\af17\loch\f0 endcase 
\par \tab \hich\af0\dbch\af17\loch\f0 get_and_check_parity; \tab // receive and check parity bit, if any 
\par \tab \hich\af0\dbch\af17\loch\f0 mark_char_received; 
\par \hich\af0\dbch\af17\loch\f0 end 
\par \hich\af0\dbch\af17\loch\f0 endtask 
\par 
\par 
\par \hich\af0\dbch\af17\loch\f0 //******\hich\af0\dbch\af17\loch\f0 **************************************************
\par \hich\af0\dbch\af17\loch\f0 task syn_receive_external; 
\par \hich\af0\dbch\af17\loch\f0 forever 
\par \hich\af0\dbch\af17\loch\f0 begin 
\par \hich\af0\dbch\af17\loch\f0 // have not found the original programs
\par \hich\af0\dbch\af17\loch\f0 end 
\par \hich\af0\dbch\af17\loch\f0 endtask
\par 
\par \hich\af0\dbch\af17\loch\f0 task get_and_check_parity; 
\par \hich\af0\dbch\af17\loch\f0 begin 
\par \tab \hich\af0\dbch\af17\loch\f0 receivebuf=receivebuf >> (8-databits); 
\par \tab \hich\af0\dbch\af17\loch\f0 if(modreg[4] == 1) 
\par \tab \hich\af0\dbch\af17\loch\f0 begin 
\par \tab \tab \hich\af0\dbch\af17\loch\f0 @(posedge rxc_) 
\par \tab \tab \hich\af0\dbch\af17\loch\f0 if (( ^receivebuf ^ modreg[5] ^ rcd) != 1) 
\par \tab \tab \tab \hich\af0\dbch\af17\loch\f0 parity_error; 
\par \tab \hich\af0\dbch\af17\loch\f0 end 
\par \hich\af0\dbch\af17\loch\f0 end 
\par \hich\af0\dbch\af17\loch\f0 endtask 
\par \hich\af0\dbch\af17\loch\f0  
\par \hich\af0\dbch\af17\loch\f0 task mark_char_received; 
\par \hich\af0\dbch\af17\loch\f0 begin 
\par \tab \hich\af0\dbch\af17\loch\f0 if(command[2]==1) \tab // if receiving is enabled 
\par \tab \hich\af0\dbch\af17\loch\f0 begin 
\par \tab \hich\af0\dbch\af17\loch\f0 rxrdy=1;\tab //set receive read status bit 
\par \tab \hich\af0\dbch\af17\loch\f0 status[1]=1;\tab //if prev\hich\af0\dbch\af17\loch\f0 ious data was not read 
\par \tab \hich\af0\dbch\af17\loch\f0 if(rdatain == 1) 
\par \tab \tab \hich\af0\dbch\af17\loch\f0 overrun_error; // overrun error 
\par \tab \hich\af0\dbch\af17\loch\f0 rdata=receivebuf;\tab //latch the data 
\par \tab \hich\af0\dbch\af17\loch\f0 rdatain=1;\tab //mark data as not having been read 
\par \tab \hich\af0\dbch\af17\loch\f0 end 
\par \hich\af0\dbch\af17\loch\f0 if(dflags[2]) 
\par \tab \hich\af0\dbch\af17\loch\f0 $display("I8251A (%h) at %d : receive data : %b", instance_id, $time,r\hich\af0\dbch\af17\loch\f0 eceivebuf); 
\par \hich\af0\dbch\af17\loch\f0 end 
\par \hich\af0\dbch\af17\loch\f0 endtask 
\par \hich\af0\dbch\af17\loch\f0  
\par \hich\af0\dbch\af17\loch\f0  
\par \hich\af0\dbch\af17\loch\f0 /************* ASYNCHRONOUS MODE RECEIVER ****************/ 
\par \hich\af0\dbch\af17\loch\f0 /* CHECK FOR BREAK DETECTION (RCD LOW THROUGH 2 */ 
\par \hich\af0\dbch\af17\loch\f0 /* RECEIVE SEQUENCES IN THE ASYNCHRONOUS MODE .*/ 
\par \hich\af0\dbch\af17\loch\f0  
\par \hich\af0\dbch\af17\loch\f0 always @ (break_detect_e) 
\par \hich\af0\dbch\af17\loch\f0 begin :break_detect_blk 
\par \tab \hich\af0\dbch\af17\loch\f0 #1 /* \hich\af0\dbch\af17\loch\f0 to be sure break_delay_clk is waiting on break_delay_e 
\par \tab \tab \hich\af0\dbch\af17\loch\f0 after it triggered break_detect_e */ 
\par \tab \hich\af0\dbch\af17\loch\f0 if (rcd==0) 
\par \tab \hich\af0\dbch\af17\loch\f0 begin 
\par \tab \tab \hich\af0\dbch\af17\loch\f0 ->break_delay_e; // start + databits +parity +stop bit 
\par \tab \tab \hich\af0\dbch\af17\loch\f0 breakcount_period = 1 +databits + modreg[4] + (tstoptotal!=0); 
\par \tab \tab \hich\af0\dbch\af17\loch\f0 // the numbe\hich\af0\dbch\af17\loch\f0 r of rxc periods needed for 2 receive sequence  
\par \tab \tab \hich\af0\dbch\af17\loch\f0 breakcount_period  = 2* breakcount_period*baudmx; 
\par \tab \tab \hich\af0\dbch\af17\loch\f0 //if rcd stays low through 2 consecutive  
\par \tab \tab \hich\af0\dbch\af17\loch\f0 // (start ,data,prity ,stop ) sequences ...  
\par \tab \tab \hich\af0\dbch\af17\loch\f0 repeat(breakcount_period) 
\par \tab \tab \tab \hich\af0\dbch\af17\loch\f0 @(posedge rxc_); 
\par \tab \tab \hich\af0\dbch\af17\loch\f0 status[6]\hich\af0\dbch\af17\loch\f0 =1;\tab // ... then set break detect (status[6]) high 
\par \tab \hich\af0\dbch\af17\loch\f0 end 
\par \hich\af0\dbch\af17\loch\f0 end 
\par \hich\af0\dbch\af17\loch\f0  
\par \hich\af0\dbch\af17\loch\f0 always @(break_delay_e)\tab \tab 
\par \hich\af0\dbch\af17\loch\f0 begin : break_delay_blk 
\par \tab \hich\af0\dbch\af17\loch\f0 @(posedge rcd )\tab //but if rcd goes high during that time 
\par \tab \hich\af0\dbch\af17\loch\f0 begin :break_delay_blk   
\par \tab \tab \hich\af0\dbch\af17\loch\f0 disable break_detect_blk; 
\par \tab \tab \hich\af0\dbch\af17\loch\f0 status[6] = 0;\tab //... then\hich\af0\dbch\af17\loch\f0  set the break detect low 
\par \tab \tab \hich\af0\dbch\af17\loch\f0 @(negedge rcd ) \tab //and when rcd goes low again ... 
\par \tab \tab \hich\af0\dbch\af17\loch\f0 ->break_detect_e; \tab // ... start the break detection again 
\par \tab \hich\af0\dbch\af17\loch\f0 end 
\par \hich\af0\dbch\af17\loch\f0 end 
\par \hich\af0\dbch\af17\loch\f0  
\par \hich\af0\dbch\af17\loch\f0 /******** ASYNCHRONOUS MODE RECEIVE TASK ******************/ 
\par \hich\af0\dbch\af17\loch\f0 task asyn_receive; 
\par \hich\af0\dbch\af17\loch\f0 forever  
\par \tab \hich\af0\dbch\af17\loch\f0 @(negedg\hich\af0\dbch\af17\loch\f0 e rcd) // the receive line went to zero, maybe a start bit 
\par \tab \hich\af0\dbch\af17\loch\f0 begin 
\par \tab \tab \hich\af0\dbch\af17\loch\f0 rbaudcnt = baudmx /2; 
\par \tab \tab \hich\af0\dbch\af17\loch\f0 if (baudmx == 1) 
\par \tab \tab \tab \hich\af0\dbch\af17\loch\f0 rbaudcnt=1; 
\par \tab \tab \hich\af0\dbch\af17\loch\f0 repeat(rbaudcnt) @(posedge rxc_); // after half a bit ... 
\par \tab \tab \hich\af0\dbch\af17\loch\f0 if(rcd == 0)\tab //if it is still a start bit 
\par \tab \tab \hich\af0\dbch\af17\loch\f0 begin 
\par \tab \tab \tab \hich\af0\dbch\af17\loch\f0 rbaudcnt \hich\af0\dbch\af17\loch\f0 = baudmx; 
\par \tab \tab \tab \hich\af0\dbch\af17\loch\f0 repeat(databits) // receive the data bits 
\par \tab \tab \tab \hich\af0\dbch\af17\loch\f0 begin 
\par \tab \tab \tab \tab \hich\af0\dbch\af17\loch\f0 repeat(rbaudcnt ) @(posedge rxc_); 
\par \tab \tab \tab \tab \hich\af0\dbch\af17\loch\f0 #1 receivebuf=\{rcd,receivebuf[7:1]\}; 
\par \tab \tab \tab \hich\af0\dbch\af17\loch\f0 end 
\par \tab \tab \tab \hich\af0\dbch\af17\loch\f0 repeat (rbaudcnt) @(posedge rxc_); 
\par \hich\af0\dbch\af17\loch\f0  
\par \tab \tab \tab \tab \hich\af0\dbch\af17\loch\f0 //shift the data to the low part 
\par \tab \tab \tab \hich\af0\dbch\af17\loch\f0 receivebuf = rece\hich\af0\dbch\af17\loch\f0 ivebuf >> (8-databits); 
\par \tab \tab \tab \hich\af0\dbch\af17\loch\f0 if(modreg[4]==1)\tab ///if parity is enabled 
\par \tab \tab \tab \hich\af0\dbch\af17\loch\f0 begin 
\par \tab \tab \tab \tab \hich\af0\dbch\af17\loch\f0 if ((^receivebuf ^ modreg[5]^rcd)!=1) 
\par \tab \tab \tab \tab \tab \hich\af0\dbch\af17\loch\f0 parity_error;\tab //check for a parity error 
\par \tab \tab \tab \tab \hich\af0\dbch\af17\loch\f0 repeat(rbaudcnt) @(posedge rxc_); 
\par \tab \tab \tab \hich\af0\dbch\af17\loch\f0 end 
\par \hich\af0\dbch\af17\loch\f0  
\par \tab \tab \tab \hich\af0\dbch\af17\loch\f0 #1 if (rcd == 0 )\tab  // if middle of\hich\af0\dbch\af17\loch\f0  stop bit is 0 
\par \tab \tab \tab \tab \hich\af0\dbch\af17\loch\f0 frame_error;\tab // frame error (should be 1) 
\par \tab \tab \tab \hich\af0\dbch\af17\loch\f0  
\par \tab \tab \tab \hich\af0\dbch\af17\loch\f0 mark_char_received; 
\par \tab \tab \hich\af0\dbch\af17\loch\f0 end 
\par \tab \hich\af0\dbch\af17\loch\f0 end 
\par \hich\af0\dbch\af17\loch\f0 endtask 
\par \hich\af0\dbch\af17\loch\f0 endmodule 
\par \hich\af0\dbch\af17\loch\f0 //++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++ 
\par }{\b\f0 
\par 
\par \hich\af0\dbch\af17\loch\f0 //[}{\b\f0 \loch\af0\hich\af0\dbch\f17 \'c0\'fd}{\b\f0 \hich\af0\dbch\af17\loch\f0 2]. }{\b\f0 \loch\af0\hich\af0\dbch\f17 \'a1\'b0\'c9\'cc\'d2\'b5\'bb\'af\'a1\'b1\'b5\'c4\'d0\'e9\'c4\'e2\'c4\'a3\'bf\'e9\'d6\'ae\'b6\'fe}{\b\f0 
\hich\af0\dbch\af17\loch\f0 : Intel 8085a }{\b\f0 \loch\af0\hich\af0\dbch\f17 \'ce\'a2\'b4\'a6\'c0\'ed\'c6\'f7\'b5\'c4\'d0\'d0\'ce\'aa\'c3\'e8\'ca\'f6\'c4\'a3\'bf\'e9}{\b\f0 
\par }{\f0 
\par \hich\af0\dbch\af17\loch\f0 /****************************************************************************
\par }\pard \s31\qc \li0\ri0\nowidctlpar\aspalpha\aspnum\faroman\rin0\lin0\itap0 {\b\f0 \hich\af0\dbch\af17\loch\f0 Intel 8085a }{\b\f0 \loch\af0\hich\af0\dbch\f17 \'ce\'a2\'b4\'a6\'c0\'ed\'c6\'f7\'b7\'c2\'d5\'e6\'c4\'a3\'bf\'e9\'b5\'c4}{\b\f0 
\hich\af0\dbch\af17\loch\f0 Verilog}{\b\f0 \loch\af0\hich\af0\dbch\f17 \'d4\'b4\'b4\'fa\'c2\'eb}{\b\f0 
\par }\pard\plain \qc \li0\ri0\nowidctlpar\aspalpha\aspnum\faroman\rin0\lin0\itap0 \fs21\lang1033\langfe2052\kerning2\loch\af0\hich\af0\dbch\af17\cgrid\langnp1033\langfenp2052 {\fs18\dbch\af29 \loch\af0\hich\af0\dbch\f29 \'d7\'a2\'d2\'e2\'a3\'ba\'d7\'f7
\'d5\'df\'b2\'bb\'c4\'dc\'b1\'a3\'d6\'a4\'b1\'be\'c4\'a3\'bf\'e9\'b5\'c4\'cd\'ea\'d5\'fb\'ba\'cd\'be\'ab\'c8\'b7\'a3\'ac\'ca\'b9\'d3\'c3\'b1\'be\'c4\'a3\'bf\'e9\'d5\'df\'c8\'e7\'d3\'f6\'ce\'ca\'cc\'e2\'d2\'bb\'c7\'d0\'d4\'f0\'c8\'ce\'d7\'d4\'b8\'ba}{
\fs18\dbch\af29 
\par }\pard \qj \li0\ri0\nowidctlpar\aspalpha\aspnum\faroman\rin0\lin0\itap0 {\hich\af0\dbch\af17\loch\f0 *****************************************************************************/
\par }\pard\plain \s31\qj \li0\ri0\nowidctlpar\aspalpha\aspnum\faroman\rin0\lin0\itap0 \fs21\lang1033\langfe2052\kerning2\loch\af17\hich\af2\dbch\af17\cgrid\langnp1033\langfenp2052 {\f0 \hich\af0\dbch\af17\loch\f0  
\par \hich\af0\dbch\af17\loch\f0 module intel_8085a
\par \hich\af0\dbch\af17\loch\f0         (c\hich\af0\dbch\af17\loch\f0 lock, x2, resetff, sodff, sid, trap, rst7p5, rst6p5, rst5p5, 
\par \hich\af0\dbch\af17\loch\f0          intr, intaff, ad, a, s0, aleff, writeout, readout, s1,iomout, 
\par \hich\af0\dbch\af17\loch\f0          ready, nreset, clockff, hldaff, hold);
\par 
\par \hich\af0\dbch\af17\loch\f0     reg [8:1]      dflags;
\par \hich\af0\dbch\af17\loch\f0     initial         dflags = 'b011;
\par \hich\af0\dbch\af17\loch\f0     // dia\hich\af0\dbch\af17\loch\f0 g flags:
\par \hich\af0\dbch\af17\loch\f0     // 1 = trace instructions
\par \hich\af0\dbch\af17\loch\f0     // 2 = trace IN and OUT instructions
\par \hich\af0\dbch\af17\loch\f0     // 3 = trace instruction count
\par 
\par \hich\af0\dbch\af17\loch\f0     output
\par \hich\af0\dbch\af17\loch\f0         resetff, sodff, intaff, s0, aleff,
\par \hich\af0\dbch\af17\loch\f0         writeout, readout, s1, iomout, clockff, hldaff;
\par 
\par \hich\af0\dbch\af17\loch\f0     inout[7:0] ad, a;
\par 
\par \hich\af0\dbch\af17\loch\f0     in\hich\af0\dbch\af17\loch\f0 put
\par \hich\af0\dbch\af17\loch\f0             clock, x2, sid, trap,
\par \hich\af0\dbch\af17\loch\f0             rst7p5, rst6p5, rst5p5,
\par \hich\af0\dbch\af17\loch\f0             intr, ready, nreset, hold;
\par 
\par \hich\af0\dbch\af17\loch\f0     reg[15:0]
\par \hich\af0\dbch\af17\loch\f0         pc,        // program counter
\par \hich\af0\dbch\af17\loch\f0         sp,        // stack pointer
\par \hich\af0\dbch\af17\loch\f0         addr;      // address output
\par 
\par \hich\af0\dbch\af17\loch\f0     reg[8:0]
\par \hich\af0\dbch\af17\loch\f0         intmask;   // interrupt mask and status
\par 
\par \hich\af0\dbch\af17\loch\f0     reg[7:0]
\par \hich\af0\dbch\af17\loch\f0         acc,       // accumulator
\par \hich\af0\dbch\af17\loch\f0         regb,      // general
\par \hich\af0\dbch\af17\loch\f0         regc,      // general
\par \hich\af0\dbch\af17\loch\f0         regd,      // general
\par \hich\af0\dbch\af17\loch\f0         rege,      // general
\par \hich\af0\dbch\af17\loch\f0         regh,      // general
\par \hich\af0\dbch\af17\loch\f0         re\hich\af0\dbch\af17\loch\f0 gl,      // general
\par \hich\af0\dbch\af17\loch\f0         ir,        // instruction
\par \hich\af0\dbch\af17\loch\f0         data;      // data output
\par 
\par \hich\af0\dbch\af17\loch\f0     reg
\par \hich\af0\dbch\af17\loch\f0         aleff,     // address latch enable
\par \hich\af0\dbch\af17\loch\f0         s0ff,      // status line 0
\par \hich\af0\dbch\af17\loch\f0         s1ff,      // status line 1
\par \hich\af0\dbch\af17\loch\f0         hldaff,    // hold acknowledge
\par \hich\af0\dbch\af17\loch\f0      \hich\af0\dbch\af17\loch\f0    holdff,    // internal hold
\par \hich\af0\dbch\af17\loch\f0         intaff,    // interrupt acknowledge
\par \hich\af0\dbch\af17\loch\f0         trapff,    // trap interrupt request
\par \hich\af0\dbch\af17\loch\f0         trapi,     // trap execution for RIM instruction
\par \hich\af0\dbch\af17\loch\f0         inte,      // previous state of interrupt enable flag
\par \hich\af0\dbch\af17\loch\f0         int,       // interrupt acknowledge in progress
\par \hich\af0\dbch\af17\loch\f0         validint,  // interrupt pending
\par \hich\af0\dbch\af17\loch\f0         haltff,    // halt request
\par \hich\af0\dbch\af17\loch\f0         resetff,   // reset output
\par \hich\af0\dbch\af17\loch\f0         clockff,   // clock output
\par \hich\af0\dbch\af17\loch\f0         sodff,     // serial output data
\par \hich\af0\dbch\af17\loch\f0         read, \hich\af0\dbch\af17\loch\f0      // read request signal
\par \hich\af0\dbch\af17\loch\f0         write,     // write request signal
\par \hich\af0\dbch\af17\loch\f0         iomff,     // i/o memory select
\par \hich\af0\dbch\af17\loch\f0         acontrol,  // address output control
\par \hich\af0\dbch\af17\loch\f0         dcontrol,  // data output control
\par \hich\af0\dbch\af17\loch\f0         s,         // data source control
\par \hich\af0\dbch\af17\loch\f0         cs,     \hich\af0\dbch\af17\loch\f0    // sign condition code
\par \hich\af0\dbch\af17\loch\f0         cz,        // zero condition code
\par \hich\af0\dbch\af17\loch\f0         cac,       // aux carry condition code
\par \hich\af0\dbch\af17\loch\f0         cp,        // parity condition code
\par \hich\af0\dbch\af17\loch\f0         cc;        // carry condition code
\par 
\par \hich\af0\dbch\af17\loch\f0     wire
\par \hich\af0\dbch\af17\loch\f0         s0 = s0ff & ~haltff,
\par \hich\af0\dbch\af17\loch\f0         s1 = s1\hich\af0\dbch\af17\loch\f0 ff & ~haltff;
\par 
\par \hich\af0\dbch\af17\loch\f0     tri[7:0]
\par \hich\af0\dbch\af17\loch\f0         ad = dcontrol ? (s ? data : addr[7:0]) : 'bz,
\par \hich\af0\dbch\af17\loch\f0         a = acontrol ? addr[15:8] : 'bz;
\par 
\par \hich\af0\dbch\af17\loch\f0     tri
\par \hich\af0\dbch\af17\loch\f0         readout = acontrol ? read : 'bz,
\par \hich\af0\dbch\af17\loch\f0         writeout = acontrol ? write : 'bz,
\par \hich\af0\dbch\af17\loch\f0         iomout = acontrol ? iomff : 'bz;
\par 
\par \hich\af0\dbch\af17\loch\f0     event
\par \hich\af0\dbch\af17\loch\f0         ec1, // clock 1 event
\par \hich\af0\dbch\af17\loch\f0         ec2; // clock 2 event
\par 
\par \hich\af0\dbch\af17\loch\f0     // internal clock generation
\par \hich\af0\dbch\af17\loch\f0     always begin
\par \hich\af0\dbch\af17\loch\f0         @(posedge clock) -> ec1;
\par \hich\af0\dbch\af17\loch\f0         @(posedge clock) -> ec2;
\par \hich\af0\dbch\af17\loch\f0     end
\par 
\par \hich\af0\dbch\af17\loch\f0     integer instruction; // instruction count
\par \hich\af0\dbch\af17\loch\f0     initial \hich\af0\dbch\af17\loch\f0 instruction = 0;
\par 
\par \hich\af0\dbch\af17\loch\f0     always begin:run_processor
\par \hich\af0\dbch\af17\loch\f0         #1 reset_sequence;
\par \hich\af0\dbch\af17\loch\f0         fork                                            
\par \hich\af0\dbch\af17\loch\f0             execute_instructions;             // Instructions executed
\par \hich\af0\dbch\af17\loch\f0             wait(!nreset)                     // in \hich\af0\dbch\af17\loch\f0 parallel with reset  
\par \hich\af0\dbch\af17\loch\f0                 @ec2 disable run_processor; // control. Reset will     
\par \hich\af0\dbch\af17\loch\f0         join                                  // disable run_processor   
\par \hich\af0\dbch\af17\loch\f0     end                                       // and all tasks and       
\par \hich\af0\dbch\af17\loch\f0               \hich\af0\dbch\af17\loch\f0                                 // functions enabled from  
\par \hich\af0\dbch\af17\loch\f0                                               // it when nreset set to 0.
\par 
\par \hich\af0\dbch\af17\loch\f0     task reset_sequence;
\par \hich\af0\dbch\af17\loch\f0     begin
\par \hich\af0\dbch\af17\loch\f0         wait(!nreset)
\par \hich\af0\dbch\af17\loch\f0         fork
\par \hich\af0\dbch\af17\loch\f0             begin
\par \hich\af0\dbch\af17\loch\f0                 $display("Performing 8085(%m) reset sequence");
\par \hich\af0\dbch\af17\loch\f0                 read = 1;
\par \hich\af0\dbch\af17\loch\f0                 write = 1;
\par \hich\af0\dbch\af17\loch\f0                 resetff = 1;
\par \hich\af0\dbch\af17\loch\f0                 dcontrol = 0;
\par \hich\af0\dbch\af17\loch\f0                 @ec1 // synchronized with clock 1 event
\par \hich\af0\dbch\af17\loch\f0                     pc =\hich\af0\dbch\af17\loch\f0  0;
\par \hich\af0\dbch\af17\loch\f0                     ir = 0;
\par \hich\af0\dbch\af17\loch\f0                     intmask[3:0] = 7;
\par \hich\af0\dbch\af17\loch\f0                     intaff = 1;
\par \hich\af0\dbch\af17\loch\f0                     acontrol = 0;
\par \hich\af0\dbch\af17\loch\f0                     aleff = 0;
\par \hich\af0\dbch\af17\loch\f0                     intmask[7:5] = 0;
\par \hich\af0\dbch\af17\loch\f0                     sodff = 0;
\par \hich\af0\dbch\af17\loch\f0                     \hich\af0\dbch\af17\loch\f0 trapff = 0;
\par \hich\af0\dbch\af17\loch\f0                     trapi = 0;
\par \hich\af0\dbch\af17\loch\f0                     iomff = 0;
\par \hich\af0\dbch\af17\loch\f0                     haltff = 0;
\par \hich\af0\dbch\af17\loch\f0                     holdff = 0;
\par \hich\af0\dbch\af17\loch\f0                     hldaff = 0;
\par \hich\af0\dbch\af17\loch\f0                     validint = 0;
\par \hich\af0\dbch\af17\loch\f0                     int = 0;
\par \hich\af0\dbch\af17\loch\f0                 disable\hich\af0\dbch\af17\loch\f0  check_reset;
\par \hich\af0\dbch\af17\loch\f0             end
\par \hich\af0\dbch\af17\loch\f0             begin:check_reset
\par \hich\af0\dbch\af17\loch\f0                 wait(nreset)               // Check, in parallel with the
\par \hich\af0\dbch\af17\loch\f0                     disable run_processor; // reset sequence, that nreset
\par \hich\af0\dbch\af17\loch\f0             end                            // remains at 0.
\par \hich\af0\dbch\af17\loch\f0         join
\par \hich\af0\dbch\af17\loch\f0         wait(nreset) @ec1 @ec2 resetff = 0;
\par \hich\af0\dbch\af17\loch\f0     end
\par \hich\af0\dbch\af17\loch\f0     endtask
\par 
\par 
\par \hich\af0\dbch\af17\loch\f0     /* fetch and execute instructions */
\par \hich\af0\dbch\af17\loch\f0     task execute_instructions;
\par \hich\af0\dbch\af17\loch\f0     forever begin
\par \hich\af0\dbch\af17\loch\f0         instruction = instr\hich\af0\dbch\af17\loch\f0 uction + 1;
\par \hich\af0\dbch\af17\loch\f0         if(dflags[3])
\par \hich\af0\dbch\af17\loch\f0             $display("executing instruction %d", instruction);
\par 
\par \hich\af0\dbch\af17\loch\f0         @ec1 // clock cycle 1
\par \hich\af0\dbch\af17\loch\f0             addr = pc;
\par \hich\af0\dbch\af17\loch\f0             s = 0;
\par \hich\af0\dbch\af17\loch\f0             iomff = 0;
\par \hich\af0\dbch\af17\loch\f0             read = 1;
\par \hich\af0\dbch\af17\loch\f0             write = 1;
\par \hich\af0\dbch\af17\loch\f0             acontr\hich\af0\dbch\af17\loch\f0 ol = 1;
\par \hich\af0\dbch\af17\loch\f0             dcontrol = 1;
\par \hich\af0\dbch\af17\loch\f0             aleff = 1;
\par \hich\af0\dbch\af17\loch\f0             if(haltff) begin
\par \hich\af0\dbch\af17\loch\f0                 haltff = 1;
\par \hich\af0\dbch\af17\loch\f0                 s0ff = 0;
\par \hich\af0\dbch\af17\loch\f0                 s1ff = 0;
\par \hich\af0\dbch\af17\loch\f0                 haltreq;
\par \hich\af0\dbch\af17\loch\f0             end
\par \hich\af0\dbch\af17\loch\f0             else begin
\par \hich\af0\dbch\af17\loch\f0                 s0ff = 1;
\par \hich\af0\dbch\af17\loch\f0                 s1ff = 1;
\par \hich\af0\dbch\af17\loch\f0             end
\par \hich\af0\dbch\af17\loch\f0         @ec2
\par \hich\af0\dbch\af17\loch\f0             aleff = 0;
\par 
\par \hich\af0\dbch\af17\loch\f0         @ec1 // clock cycle 2
\par \hich\af0\dbch\af17\loch\f0             read = 0;
\par \hich\af0\dbch\af17\loch\f0             dcontrol = 0;
\par \hich\af0\dbch\af17\loch\f0         @ec2
\par \hich\af0\dbch\af17\loch\f0             ready_hold;
\par 
\par \hich\af0\dbch\af17\loch\f0         @ec2 // clock cycle 3
\par \hich\af0\dbch\af17\loch\f0             read = 1;
\par \hich\af0\dbch\af17\loch\f0          \hich\af0\dbch\af17\loch\f0    data = ad;
\par \hich\af0\dbch\af17\loch\f0             ir = ad;
\par 
\par \hich\af0\dbch\af17\loch\f0         @ec1 // clock cycle 4
\par \hich\af0\dbch\af17\loch\f0             if(do6cycles(ir)) begin
\par \hich\af0\dbch\af17\loch\f0                 // do a 6-cycle instruction fetch
\par \hich\af0\dbch\af17\loch\f0                 @ec1 @ec2 // conditional clock cycle 5
\par \hich\af0\dbch\af17\loch\f0                     if(hold) begin
\par \hich\af0\dbch\af17\loch\f0               \hich\af0\dbch\af17\loch\f0           holdff =1 ;
\par \hich\af0\dbch\af17\loch\f0                         acontrol = 0;
\par \hich\af0\dbch\af17\loch\f0                         dcontrol = 0;
\par \hich\af0\dbch\af17\loch\f0                         @ec2 hldaff = 1;
\par \hich\af0\dbch\af17\loch\f0                     end
\par \hich\af0\dbch\af17\loch\f0                     else begin
\par \hich\af0\dbch\af17\loch\f0                         holdff = 0;
\par \hich\af0\dbch\af17\loch\f0                         hldaff = 0;
\par \hich\af0\dbch\af17\loch\f0                     end
\par 
\par \hich\af0\dbch\af17\loch\f0                 @ec1; // conditional clock cycle 6
\par \hich\af0\dbch\af17\loch\f0             end
\par 
\par \hich\af0\dbch\af17\loch\f0             if(holdff) holdit;
\par \hich\af0\dbch\af17\loch\f0             checkint;
\par \hich\af0\dbch\af17\loch\f0             do_instruction;
\par 
\par \hich\af0\dbch\af17\loch\f0             while(hold) @ec2 begin
\par \hich\af0\dbch\af17\loch\f0           \hich\af0\dbch\af17\loch\f0       acontrol = 0;
\par \hich\af0\dbch\af17\loch\f0                 dcontrol = 0;
\par \hich\af0\dbch\af17\loch\f0             end
\par \hich\af0\dbch\af17\loch\f0             holdff = 0;
\par \hich\af0\dbch\af17\loch\f0             hldaff = 0;
\par \hich\af0\dbch\af17\loch\f0             if(validint) interrupt;
\par \hich\af0\dbch\af17\loch\f0     end
\par \hich\af0\dbch\af17\loch\f0     endtask
\par 
\par 
\par \hich\af0\dbch\af17\loch\f0     function do6cycles;
\par \hich\af0\dbch\af17\loch\f0     input[7:0] ireg;
\par \hich\af0\dbch\af17\loch\f0     begin
\par \hich\af0\dbch\af17\loch\f0         do6cycles = 0;
\par \hich\af0\dbch\af17\loch\f0         case(ireg[2:0])
\par \hich\af0\dbch\af17\loch\f0             0, 4, 5, 7: if(ireg[7:6] == 3) do6cycles = 1;
\par \hich\af0\dbch\af17\loch\f0             1: if((ireg[3] == 1) && (ireg[7:5] == 7)) do6cycles = 1;
\par \hich\af0\dbch\af17\loch\f0             3: if(ireg[7:6] == 0) do6cycles = 1;
\par \hich\af0\dbch\af17\loch\f0         endcase
\par \hich\af0\dbch\af17\loch\f0     end
\par \hich\af0\dbch\af17\loch\f0     endfunction
\par 
\par 
\par \hich\af0\dbch\af17\loch\f0     task check\hich\af0\dbch\af17\loch\f0 int;
\par \hich\af0\dbch\af17\loch\f0     begin
\par \hich\af0\dbch\af17\loch\f0         if(rst6p5)
\par \hich\af0\dbch\af17\loch\f0             if((intmask[3] == 1) && (intmask[1] == 0)) intmask[6] = 1;
\par \hich\af0\dbch\af17\loch\f0         else
\par \hich\af0\dbch\af17\loch\f0             intmask[6] = 0;
\par 
\par \hich\af0\dbch\af17\loch\f0         if(rst5p5)
\par \hich\af0\dbch\af17\loch\f0             if((intmask[3] == 1) && (intmask[0] == 0)) intmask[5] = 1;
\par \hich\af0\dbch\af17\loch\f0         else
\par \hich\af0\dbch\af17\loch\f0       \hich\af0\dbch\af17\loch\f0       intmask[5] = 0;
\par 
\par \hich\af0\dbch\af17\loch\f0         if(\{intmask[7], intmask[3:2]\} == 6)
\par \hich\af0\dbch\af17\loch\f0             intmask[4] = 1;
\par \hich\af0\dbch\af17\loch\f0         else
\par \hich\af0\dbch\af17\loch\f0             intmask[4] = 0;
\par 
\par \hich\af0\dbch\af17\loch\f0         validint = (intmask[6:4] == 7) | trapff | intr;
\par \hich\af0\dbch\af17\loch\f0     end
\par \hich\af0\dbch\af17\loch\f0     endtask
\par 
\par 
\par \hich\af0\dbch\af17\loch\f0     // concurently with executing instructions,
\par \hich\af0\dbch\af17\loch\f0     // process primary inputs for processor interrupt
\par \hich\af0\dbch\af17\loch\f0     always @(posedge trap) trapff = 1;
\par 
\par \hich\af0\dbch\af17\loch\f0     always @(negedge trap) trapff = 0;
\par 
\par \hich\af0\dbch\af17\loch\f0     always @(posedge rst7p5) intmask[7] = 1;
\par 
\par 
\par \hich\af0\dbch\af17\loch\f0     /* check condition of r\hich\af0\dbch\af17\loch\f0 eady and hold inputs */
\par \hich\af0\dbch\af17\loch\f0     task ready_hold;
\par \hich\af0\dbch\af17\loch\f0     begin
\par \hich\af0\dbch\af17\loch\f0         while(!ready) @ec2;
\par \hich\af0\dbch\af17\loch\f0         @ec1
\par \hich\af0\dbch\af17\loch\f0             if(hold) begin
\par \hich\af0\dbch\af17\loch\f0                 holdff = 1;
\par \hich\af0\dbch\af17\loch\f0                 @ec2 hldaff = 1;
\par \hich\af0\dbch\af17\loch\f0             end
\par \hich\af0\dbch\af17\loch\f0     end
\par \hich\af0\dbch\af17\loch\f0     endtask
\par 
\par 
\par \hich\af0\dbch\af17\loch\f0     /* hold */
\par \hich\af0\dbch\af17\loch\f0     task holdit;
\par \hich\af0\dbch\af17\loch\f0   \hich\af0\dbch\af17\loch\f0   begin
\par \hich\af0\dbch\af17\loch\f0         while(hold) @ec2 begin
\par \hich\af0\dbch\af17\loch\f0             acontrol = 0;
\par \hich\af0\dbch\af17\loch\f0             dcontrol = 0;
\par \hich\af0\dbch\af17\loch\f0         end
\par \hich\af0\dbch\af17\loch\f0         holdff = 0;
\par \hich\af0\dbch\af17\loch\f0         @ec2 hldaff = 0;
\par \hich\af0\dbch\af17\loch\f0     end
\par \hich\af0\dbch\af17\loch\f0     endtask
\par 
\par 
\par 
\par \hich\af0\dbch\af17\loch\f0     /* halt request */
\par \hich\af0\dbch\af17\loch\f0     task haltreq;
\par \hich\af0\dbch\af17\loch\f0     forever begin
\par \hich\af0\dbch\af17\loch\f0         @ec2
\par \hich\af0\dbch\af17\loch\f0             i\hich\af0\dbch\af17\loch\f0 f(validint) begin
\par \hich\af0\dbch\af17\loch\f0                 haltff = 0;
\par \hich\af0\dbch\af17\loch\f0                 interrupt;
\par \hich\af0\dbch\af17\loch\f0                 disable haltreq;
\par \hich\af0\dbch\af17\loch\f0             end
\par \hich\af0\dbch\af17\loch\f0             else begin
\par \hich\af0\dbch\af17\loch\f0                 while(hold) @ec2 hldaff = 1;
\par \hich\af0\dbch\af17\loch\f0                 hldaff = 0;
\par \hich\af0\dbch\af17\loch\f0                 @ec2;
\par \hich\af0\dbch\af17\loch\f0             end
\par 
\par \hich\af0\dbch\af17\loch\f0         @ec1 #10
\par \hich\af0\dbch\af17\loch\f0             dcontrol = 0;
\par \hich\af0\dbch\af17\loch\f0             acontrol = 0;
\par \hich\af0\dbch\af17\loch\f0             checkint;
\par \hich\af0\dbch\af17\loch\f0     end
\par \hich\af0\dbch\af17\loch\f0     endtask
\par 
\par \hich\af0\dbch\af17\loch\f0     /* memory read */
\par \hich\af0\dbch\af17\loch\f0     task memread;
\par \hich\af0\dbch\af17\loch\f0     output[7:0] rdata;
\par \hich\af0\dbch\af17\loch\f0     input[15:0] raddr;
\par \hich\af0\dbch\af17\loch\f0     begin
\par \hich\af0\dbch\af17\loch\f0         @ec1
\par \hich\af0\dbch\af17\loch\f0             addr = raddr;
\par \hich\af0\dbch\af17\loch\f0         \hich\af0\dbch\af17\loch\f0     s = 0;
\par \hich\af0\dbch\af17\loch\f0             acontrol = 1;
\par \hich\af0\dbch\af17\loch\f0             dcontrol = 1;
\par \hich\af0\dbch\af17\loch\f0             iomff = int;
\par \hich\af0\dbch\af17\loch\f0             s0ff = int;
\par \hich\af0\dbch\af17\loch\f0             s1ff = 1;
\par \hich\af0\dbch\af17\loch\f0             aleff = 1;
\par \hich\af0\dbch\af17\loch\f0         @ec2
\par \hich\af0\dbch\af17\loch\f0             aleff = 0;
\par 
\par \hich\af0\dbch\af17\loch\f0         @ec1 
\par \hich\af0\dbch\af17\loch\f0             dcontrol = 0;
\par \hich\af0\dbch\af17\loch\f0             if(int)
\par \hich\af0\dbch\af17\loch\f0   \hich\af0\dbch\af17\loch\f0               intaff = 0;
\par \hich\af0\dbch\af17\loch\f0             else
\par \hich\af0\dbch\af17\loch\f0                 read = 0;
\par \hich\af0\dbch\af17\loch\f0         @ec2
\par \hich\af0\dbch\af17\loch\f0             ready_hold;
\par \hich\af0\dbch\af17\loch\f0             checkint;
\par 
\par \hich\af0\dbch\af17\loch\f0         @ec2
\par \hich\af0\dbch\af17\loch\f0             intaff = 1;
\par \hich\af0\dbch\af17\loch\f0             read = 1;
\par \hich\af0\dbch\af17\loch\f0             rdata = ad;
\par \hich\af0\dbch\af17\loch\f0         if(holdff) holdit;
\par \hich\af0\dbch\af17\loch\f0     end
\par \hich\af0\dbch\af17\loch\f0     endta\hich\af0\dbch\af17\loch\f0 sk
\par 
\par \hich\af0\dbch\af17\loch\f0     /* memory write */
\par \hich\af0\dbch\af17\loch\f0     task memwrite;
\par \hich\af0\dbch\af17\loch\f0     input[7:0] wdata;
\par \hich\af0\dbch\af17\loch\f0     input[15:0] waddr;
\par \hich\af0\dbch\af17\loch\f0     begin
\par \hich\af0\dbch\af17\loch\f0         @ec1
\par \hich\af0\dbch\af17\loch\f0             aleff = 1;
\par \hich\af0\dbch\af17\loch\f0             s0ff = 1;
\par \hich\af0\dbch\af17\loch\f0             s1ff = 0;
\par \hich\af0\dbch\af17\loch\f0             s = 0;
\par \hich\af0\dbch\af17\loch\f0             iomff = 0;
\par \hich\af0\dbch\af17\loch\f0             addr = waddr;
\par \hich\af0\dbch\af17\loch\f0        \hich\af0\dbch\af17\loch\f0      acontrol = 1;
\par \hich\af0\dbch\af17\loch\f0             dcontrol = 1;
\par \hich\af0\dbch\af17\loch\f0         @ec2
\par \hich\af0\dbch\af17\loch\f0             aleff = 0;
\par 
\par \hich\af0\dbch\af17\loch\f0         @ec1
\par \hich\af0\dbch\af17\loch\f0             data = wdata;
\par \hich\af0\dbch\af17\loch\f0             write = 0;
\par \hich\af0\dbch\af17\loch\f0             s = 1;
\par \hich\af0\dbch\af17\loch\f0         @ec2
\par \hich\af0\dbch\af17\loch\f0             ready_hold;
\par \hich\af0\dbch\af17\loch\f0             checkint;
\par 
\par \hich\af0\dbch\af17\loch\f0         @ec2
\par \hich\af0\dbch\af17\loch\f0             write = \hich\af0\dbch\af17\loch\f0 1;
\par \hich\af0\dbch\af17\loch\f0         if(holdff) holdit;
\par \hich\af0\dbch\af17\loch\f0     end
\par \hich\af0\dbch\af17\loch\f0     endtask
\par 
\par \hich\af0\dbch\af17\loch\f0     /* reads from an i/o port */
\par \hich\af0\dbch\af17\loch\f0     task ioread;
\par \hich\af0\dbch\af17\loch\f0     input[7:0] sa;
\par \hich\af0\dbch\af17\loch\f0     begin
\par \hich\af0\dbch\af17\loch\f0         @ec1
\par \hich\af0\dbch\af17\loch\f0             aleff = 1;
\par \hich\af0\dbch\af17\loch\f0             s0ff = 0;
\par \hich\af0\dbch\af17\loch\f0             s1ff = 1;
\par \hich\af0\dbch\af17\loch\f0             s = 0;
\par \hich\af0\dbch\af17\loch\f0             iomff = 1;
\par \hich\af0\dbch\af17\loch\f0     \hich\af0\dbch\af17\loch\f0         addr = \{sa, sa\};
\par \hich\af0\dbch\af17\loch\f0             acontrol = 1;
\par \hich\af0\dbch\af17\loch\f0             dcontrol = 1;
\par 
\par \hich\af0\dbch\af17\loch\f0         @ec2
\par \hich\af0\dbch\af17\loch\f0             aleff = 0;
\par 
\par \hich\af0\dbch\af17\loch\f0         @ec1
\par \hich\af0\dbch\af17\loch\f0             dcontrol = 0;
\par \hich\af0\dbch\af17\loch\f0             if(int)
\par \hich\af0\dbch\af17\loch\f0                 intaff = 0;
\par \hich\af0\dbch\af17\loch\f0             else
\par \hich\af0\dbch\af17\loch\f0                 read = 0;
\par 
\par \hich\af0\dbch\af17\loch\f0         @e\hich\af0\dbch\af17\loch\f0 c2
\par \hich\af0\dbch\af17\loch\f0             ready_hold;
\par 
\par \hich\af0\dbch\af17\loch\f0             checkint;
\par 
\par \hich\af0\dbch\af17\loch\f0         @ec2
\par \hich\af0\dbch\af17\loch\f0             intaff = 1;
\par \hich\af0\dbch\af17\loch\f0             read = 1;
\par \hich\af0\dbch\af17\loch\f0             acc = ad;
\par \hich\af0\dbch\af17\loch\f0             if(dflags[2])
\par \hich\af0\dbch\af17\loch\f0                 $display("IN %h   data = %h", sa, acc);
\par \hich\af0\dbch\af17\loch\f0     end
\par \hich\af0\dbch\af17\loch\f0     endtask
\par 
\par \hich\af0\dbch\af17\loch\f0     /* writes into i/\hich\af0\dbch\af17\loch\f0 o port */
\par \hich\af0\dbch\af17\loch\f0     task iowrite;
\par \hich\af0\dbch\af17\loch\f0     input[7:0] sa;
\par \hich\af0\dbch\af17\loch\f0     begin
\par \hich\af0\dbch\af17\loch\f0         @ec1
\par \hich\af0\dbch\af17\loch\f0             addr = \{sa, sa\};
\par \hich\af0\dbch\af17\loch\f0             aleff = 1;
\par \hich\af0\dbch\af17\loch\f0             s0ff = 1;
\par \hich\af0\dbch\af17\loch\f0             s1ff = 0;
\par \hich\af0\dbch\af17\loch\f0             s = 0;
\par \hich\af0\dbch\af17\loch\f0             iomff = 1;
\par \hich\af0\dbch\af17\loch\f0             acontrol = 1;
\par \hich\af0\dbch\af17\loch\f0             dcontrol =\hich\af0\dbch\af17\loch\f0  1;
\par 
\par \hich\af0\dbch\af17\loch\f0         @ec2
\par \hich\af0\dbch\af17\loch\f0             aleff = 0;
\par 
\par \hich\af0\dbch\af17\loch\f0         @ec1
\par \hich\af0\dbch\af17\loch\f0             data = acc;
\par \hich\af0\dbch\af17\loch\f0             write = 0;
\par \hich\af0\dbch\af17\loch\f0             s = 1;
\par 
\par \hich\af0\dbch\af17\loch\f0             if(dflags[2])
\par \hich\af0\dbch\af17\loch\f0                 $display("OUT %h   data = %h", sa, acc);
\par 
\par \hich\af0\dbch\af17\loch\f0         @ec2
\par \hich\af0\dbch\af17\loch\f0             ready_hold;
\par 
\par \hich\af0\dbch\af17\loch\f0             \hich\af0\dbch\af17\loch\f0 checkint;
\par 
\par \hich\af0\dbch\af17\loch\f0         @ec2
\par \hich\af0\dbch\af17\loch\f0             write = 1;
\par \hich\af0\dbch\af17\loch\f0             if(holdff) holdit;
\par \hich\af0\dbch\af17\loch\f0     end
\par \hich\af0\dbch\af17\loch\f0     endtask
\par 
\par \hich\af0\dbch\af17\loch\f0     task interrupt;
\par \hich\af0\dbch\af17\loch\f0     begin
\par \hich\af0\dbch\af17\loch\f0         @ec1
\par \hich\af0\dbch\af17\loch\f0             if(hold) begin
\par \hich\af0\dbch\af17\loch\f0                 holdff = 1;
\par \hich\af0\dbch\af17\loch\f0                 holdit;
\par \hich\af0\dbch\af17\loch\f0                 @ec2 hldaff = 1;
\par \hich\af0\dbch\af17\loch\f0   \hich\af0\dbch\af17\loch\f0           end
\par \hich\af0\dbch\af17\loch\f0             if(trapff) begin
\par \hich\af0\dbch\af17\loch\f0                 inte = intmask[3];
\par \hich\af0\dbch\af17\loch\f0                 trapi = 1;
\par \hich\af0\dbch\af17\loch\f0                 intic;
\par \hich\af0\dbch\af17\loch\f0                 pc = 'h24;
\par \hich\af0\dbch\af17\loch\f0                 trapi = 1;
\par \hich\af0\dbch\af17\loch\f0                 trapff = 0;
\par \hich\af0\dbch\af17\loch\f0             end
\par \hich\af0\dbch\af17\loch\f0             else if(intmask[7]\hich\af0\dbch\af17\loch\f0 ) begin
\par \hich\af0\dbch\af17\loch\f0                 intic;
\par \hich\af0\dbch\af17\loch\f0                 pc = 'h3c;
\par \hich\af0\dbch\af17\loch\f0                 intmask[7] = 0;
\par \hich\af0\dbch\af17\loch\f0             end
\par \hich\af0\dbch\af17\loch\f0             else if(intmask[6]) begin
\par \hich\af0\dbch\af17\loch\f0                 intic;
\par \hich\af0\dbch\af17\loch\f0                 pc = 'h34;
\par \hich\af0\dbch\af17\loch\f0                 intmask[6] = 0;
\par \hich\af0\dbch\af17\loch\f0             end
\par \hich\af0\dbch\af17\loch\f0             el\hich\af0\dbch\af17\loch\f0 se if(intmask[5]) begin
\par \hich\af0\dbch\af17\loch\f0                 intic;
\par \hich\af0\dbch\af17\loch\f0                 pc = 'h2c;
\par \hich\af0\dbch\af17\loch\f0                 intmask[5] = 0;
\par \hich\af0\dbch\af17\loch\f0             end
\par \hich\af0\dbch\af17\loch\f0             else if(intr) begin
\par \hich\af0\dbch\af17\loch\f0                 //?
\par \hich\af0\dbch\af17\loch\f0             end
\par \hich\af0\dbch\af17\loch\f0     end
\par \hich\af0\dbch\af17\loch\f0     endtask
\par 
\par \hich\af0\dbch\af17\loch\f0     task intic;
\par \hich\af0\dbch\af17\loch\f0     begin
\par \hich\af0\dbch\af17\loch\f0         aleff = 1;
\par \hich\af0\dbch\af17\loch\f0         s0ff = 1;
\par \hich\af0\dbch\af17\loch\f0         s1ff = 1;
\par \hich\af0\dbch\af17\loch\f0         s = 0;
\par \hich\af0\dbch\af17\loch\f0         iomff = 1;
\par \hich\af0\dbch\af17\loch\f0         addr = pc;
\par \hich\af0\dbch\af17\loch\f0         read = 1;
\par \hich\af0\dbch\af17\loch\f0         write = 1;
\par \hich\af0\dbch\af17\loch\f0         acontrol = 1;
\par \hich\af0\dbch\af17\loch\f0         dcontrol = 1;
\par 
\par \hich\af0\dbch\af17\loch\f0         @ec2 aleff = 0;
\par \hich\af0\dbch\af17\loch\f0         @ec1 dcontrol = 0;
\par \hich\af0\dbch\af17\loch\f0         repeat(4) @ec1;
\par \hich\af0\dbch\af17\loch\f0         pu\hich\af0\dbch\af17\loch\f0 sh2b(pc[15:8], pc[7:0]);
\par \hich\af0\dbch\af17\loch\f0     end
\par \hich\af0\dbch\af17\loch\f0     endtask
\par 
\par 
\par \hich\af0\dbch\af17\loch\f0     /* execute instruction */
\par \hich\af0\dbch\af17\loch\f0     task do_instruction;
\par \hich\af0\dbch\af17\loch\f0     begin
\par \hich\af0\dbch\af17\loch\f0       if(dflags[1])
\par \hich\af0\dbch\af17\loch\f0         $display( "C%bZ%bM%bE%bI%b A=%h B=%h%h D=%h%h H=%h%h S=%h P=%h IR=%h",
\par \hich\af0\dbch\af17\loch\f0                   cc, cz, cs, cp, cac, acc, r\hich\af0\dbch\af17\loch\f0 egb,regc, regd,rege, regh,regl,
\par \hich\af0\dbch\af17\loch\f0                   sp, pc, ir);
\par 
\par \hich\af0\dbch\af17\loch\f0         pc = pc + 1;
\par \hich\af0\dbch\af17\loch\f0         @ec2 // instruction decode synchronized with clock 2 event
\par \hich\af0\dbch\af17\loch\f0             case(ir[7:6])
\par \hich\af0\dbch\af17\loch\f0                 0:
\par \hich\af0\dbch\af17\loch\f0                     case(ir[2:0])
\par \hich\af0\dbch\af17\loch\f0                         0\hich\af0\dbch\af17\loch\f0 : newops;
\par \hich\af0\dbch\af17\loch\f0                         1: if(ir[3]) addhl; else lrpi;
\par \hich\af0\dbch\af17\loch\f0                         2: sta_lda;
\par \hich\af0\dbch\af17\loch\f0                         3: inx_dcx;
\par \hich\af0\dbch\af17\loch\f0                         4: inr;
\par \hich\af0\dbch\af17\loch\f0                         5: dcr;
\par \hich\af0\dbch\af17\loch\f0                         6: movi;
\par \hich\af0\dbch\af17\loch\f0                       \hich\af0\dbch\af17\loch\f0   7: racc_spec;
\par \hich\af0\dbch\af17\loch\f0                     endcase
\par \hich\af0\dbch\af17\loch\f0                 1:
\par \hich\af0\dbch\af17\loch\f0                     move;
\par \hich\af0\dbch\af17\loch\f0                 2:
\par \hich\af0\dbch\af17\loch\f0                     rmop;
\par \hich\af0\dbch\af17\loch\f0                 3:
\par \hich\af0\dbch\af17\loch\f0                     case(ir[2:0])
\par \hich\af0\dbch\af17\loch\f0                         0,
\par \hich\af0\dbch\af17\loch\f0                         2,
\par \hich\af0\dbch\af17\loch\f0                \hich\af0\dbch\af17\loch\f0          4: condjcr;
\par \hich\af0\dbch\af17\loch\f0                         1: if(ir[3]) decode1; else pop;
\par \hich\af0\dbch\af17\loch\f0                         3: decode2;
\par \hich\af0\dbch\af17\loch\f0                         5: if(ir[3]) decode3; else push;
\par \hich\af0\dbch\af17\loch\f0                         6: immacc;
\par \hich\af0\dbch\af17\loch\f0                         7: restart;
\par \hich\af0\dbch\af17\loch\f0                \hich\af0\dbch\af17\loch\f0      endcase
\par \hich\af0\dbch\af17\loch\f0             endcase
\par \hich\af0\dbch\af17\loch\f0     end
\par \hich\af0\dbch\af17\loch\f0     endtask
\par 
\par \hich\af0\dbch\af17\loch\f0     /* move register to register */
\par \hich\af0\dbch\af17\loch\f0     task move;
\par \hich\af0\dbch\af17\loch\f0         case(ir[2:0])
\par \hich\af0\dbch\af17\loch\f0             0: rmov(regb); // MOV -,B
\par \hich\af0\dbch\af17\loch\f0             1: rmov(regc); // MOV -,C
\par \hich\af0\dbch\af17\loch\f0             2: rmov(regd); // MOV -,D
\par \hich\af0\dbch\af17\loch\f0             3: \hich\af0\dbch\af17\loch\f0 rmov(rege); // MOV -,E
\par \hich\af0\dbch\af17\loch\f0             4: rmov(regh); // MOV -,H
\par \hich\af0\dbch\af17\loch\f0             5: rmov(regl); // MOV -,L
\par \hich\af0\dbch\af17\loch\f0             6:
\par \hich\af0\dbch\af17\loch\f0                 if(ir[5:3] == 6) haltff = 1; // HLT
\par \hich\af0\dbch\af17\loch\f0                 else begin // MOV -,M
\par \hich\af0\dbch\af17\loch\f0                     memread(data, \{regh, regl\});
\par \hich\af0\dbch\af17\loch\f0    \hich\af0\dbch\af17\loch\f0                  rmov(data);
\par \hich\af0\dbch\af17\loch\f0                 end
\par 
\par \hich\af0\dbch\af17\loch\f0             7: rmov(acc); // MOV -,A
\par \hich\af0\dbch\af17\loch\f0         endcase
\par \hich\af0\dbch\af17\loch\f0     endtask
\par 
\par \hich\af0\dbch\af17\loch\f0     /* enabled only by move */
\par \hich\af0\dbch\af17\loch\f0     task rmov;
\par \hich\af0\dbch\af17\loch\f0     input[7:0] fromreg;
\par \hich\af0\dbch\af17\loch\f0         case(ir[5:3])
\par \hich\af0\dbch\af17\loch\f0             0: regb = fromreg; // MOV B,-
\par \hich\af0\dbch\af17\loch\f0       \hich\af0\dbch\af17\loch\f0       1: regc = fromreg; // MOV C,-
\par \hich\af0\dbch\af17\loch\f0             2: regd = fromreg; // MOV D,-
\par \hich\af0\dbch\af17\loch\f0             3: rege = fromreg; // MOV E,-
\par \hich\af0\dbch\af17\loch\f0             4: regh = fromreg; // MOV H,-
\par \hich\af0\dbch\af17\loch\f0             5: regl = fromreg; // MOV L,-
\par \hich\af0\dbch\af17\loch\f0             6: memwrite(fromreg, \{regh, regl\}); // M\hich\af0\dbch\af17\loch\f0 OV M,-
\par \hich\af0\dbch\af17\loch\f0             7: acc = fromreg; // MOV A,-
\par \hich\af0\dbch\af17\loch\f0         endcase
\par \hich\af0\dbch\af17\loch\f0     endtask
\par 
\par \hich\af0\dbch\af17\loch\f0     /* move register and memory immediate */
\par \hich\af0\dbch\af17\loch\f0     task movi;
\par \hich\af0\dbch\af17\loch\f0     begin
\par \hich\af0\dbch\af17\loch\f0         case(ir[5:3])
\par \hich\af0\dbch\af17\loch\f0             0: memread(regb, pc); // MVI B
\par \hich\af0\dbch\af17\loch\f0             1: memread(regc, pc); // MVI C
\par \hich\af0\dbch\af17\loch\f0  \hich\af0\dbch\af17\loch\f0            2: memread(regd, pc); // MVI D
\par \hich\af0\dbch\af17\loch\f0             3: memread(rege, pc); // MVI E
\par \hich\af0\dbch\af17\loch\f0             4: memread(regh, pc); // MVI H
\par \hich\af0\dbch\af17\loch\f0             5: memread(regl, pc); // MVI L
\par \hich\af0\dbch\af17\loch\f0             6: // MVI M
\par \hich\af0\dbch\af17\loch\f0                 begin
\par \hich\af0\dbch\af17\loch\f0                     memread(data, pc);
\par \hich\af0\dbch\af17\loch\f0                     memwrite(data, \{regh, regl\});
\par \hich\af0\dbch\af17\loch\f0                 end
\par 
\par \hich\af0\dbch\af17\loch\f0             7: memread(acc, pc); // MVI A
\par \hich\af0\dbch\af17\loch\f0         endcase
\par \hich\af0\dbch\af17\loch\f0         pc = pc + 1;
\par \hich\af0\dbch\af17\loch\f0     end
\par \hich\af0\dbch\af17\loch\f0     endtask
\par 
\par \hich\af0\dbch\af17\loch\f0     /* increment register and memory contents */
\par \hich\af0\dbch\af17\loch\f0     task inr;
\par \hich\af0\dbch\af17\loch\f0         case(ir[5:3])
\par \hich\af0\dbch\af17\loch\f0             0: doinc(regb); // INR B
\par \hich\af0\dbch\af17\loch\f0             1: doinc(regc); // INR C
\par \hich\af0\dbch\af17\loch\f0             2: doinc(regd); // INR D
\par \hich\af0\dbch\af17\loch\f0             3: doinc(rege); // INR E
\par \hich\af0\dbch\af17\loch\f0             4: doinc(regh); // INR H
\par \hich\af0\dbch\af17\loch\f0             5: doinc(regl); // INR L
\par \hich\af0\dbch\af17\loch\f0             6: // INR M
\par \hich\af0\dbch\af17\loch\f0           \hich\af0\dbch\af17\loch\f0       begin
\par \hich\af0\dbch\af17\loch\f0                     memread(data, \{regh, regl\});
\par \hich\af0\dbch\af17\loch\f0                     doinc(data);
\par \hich\af0\dbch\af17\loch\f0                     memwrite(data, \{regh, regl\});
\par \hich\af0\dbch\af17\loch\f0                 end
\par 
\par \hich\af0\dbch\af17\loch\f0             7: doinc(acc); // INR A
\par \hich\af0\dbch\af17\loch\f0         endcase
\par \hich\af0\dbch\af17\loch\f0     endtask
\par 
\par \hich\af0\dbch\af17\loch\f0     /* enabled only from i\hich\af0\dbch\af17\loch\f0 ncrm */
\par \hich\af0\dbch\af17\loch\f0     task doinc;
\par \hich\af0\dbch\af17\loch\f0     inout[7:0] sr;
\par \hich\af0\dbch\af17\loch\f0     begin
\par \hich\af0\dbch\af17\loch\f0         cac = sr[3:0] == 'b1111;
\par \hich\af0\dbch\af17\loch\f0         sr = sr + 1;
\par \hich\af0\dbch\af17\loch\f0         calpsz(sr);
\par \hich\af0\dbch\af17\loch\f0     end
\par \hich\af0\dbch\af17\loch\f0     endtask
\par 
\par \hich\af0\dbch\af17\loch\f0     /* decrement register and memory contents */
\par \hich\af0\dbch\af17\loch\f0     task dcr;
\par \hich\af0\dbch\af17\loch\f0         case(ir[5:3])
\par \hich\af0\dbch\af17\loch\f0             0: dodec(re\hich\af0\dbch\af17\loch\f0 gb); // DCR B
\par \hich\af0\dbch\af17\loch\f0             1: dodec(regc); // DCR C
\par \hich\af0\dbch\af17\loch\f0             2: dodec(regd); // DCR D
\par \hich\af0\dbch\af17\loch\f0             3: dodec(rege); // DCR E
\par \hich\af0\dbch\af17\loch\f0             4: dodec(regh); // DCR H
\par \hich\af0\dbch\af17\loch\f0             5: dodec(regl); // DCR L
\par \hich\af0\dbch\af17\loch\f0             6: // DCR M
\par \hich\af0\dbch\af17\loch\f0                 begin
\par \hich\af0\dbch\af17\loch\f0            \hich\af0\dbch\af17\loch\f0          memread(data, \{regh, regl\});
\par \hich\af0\dbch\af17\loch\f0                     dodec(data);
\par \hich\af0\dbch\af17\loch\f0                     memwrite(data, \{regh, regl\});
\par \hich\af0\dbch\af17\loch\f0                 end
\par 
\par \hich\af0\dbch\af17\loch\f0             7: dodec(acc); // DCR A
\par \hich\af0\dbch\af17\loch\f0         endcase
\par \hich\af0\dbch\af17\loch\f0     endtask
\par 
\par \hich\af0\dbch\af17\loch\f0     /* enabled only from decrm */
\par \hich\af0\dbch\af17\loch\f0     task dodec;
\par \hich\af0\dbch\af17\loch\f0     inout[7:0] sr;
\par \hich\af0\dbch\af17\loch\f0     begin
\par \hich\af0\dbch\af17\loch\f0         cac = sr[3:0] == 0;
\par \hich\af0\dbch\af17\loch\f0         sr = sr - 1;
\par \hich\af0\dbch\af17\loch\f0         calpsz(sr);
\par \hich\af0\dbch\af17\loch\f0     end
\par \hich\af0\dbch\af17\loch\f0     endtask
\par 
\par \hich\af0\dbch\af17\loch\f0     /* register and memory acc instructions */
\par \hich\af0\dbch\af17\loch\f0     task rmop;
\par \hich\af0\dbch\af17\loch\f0         case(ir[2:0])
\par \hich\af0\dbch\af17\loch\f0             0: doacci(regb);
\par \hich\af0\dbch\af17\loch\f0             1: doacci(r\hich\af0\dbch\af17\loch\f0 egc);
\par \hich\af0\dbch\af17\loch\f0             2: doacci(regd);
\par \hich\af0\dbch\af17\loch\f0             3: doacci(rege);
\par \hich\af0\dbch\af17\loch\f0             4: doacci(regh);
\par \hich\af0\dbch\af17\loch\f0             5: doacci(regl);
\par \hich\af0\dbch\af17\loch\f0             6:
\par \hich\af0\dbch\af17\loch\f0                 begin
\par \hich\af0\dbch\af17\loch\f0                     memread(data, \{regh, regl\});
\par \hich\af0\dbch\af17\loch\f0                     doacci(data);
\par \hich\af0\dbch\af17\loch\f0               \hich\af0\dbch\af17\loch\f0   end
\par 
\par \hich\af0\dbch\af17\loch\f0             7: doacci(acc);
\par \hich\af0\dbch\af17\loch\f0         endcase
\par \hich\af0\dbch\af17\loch\f0     endtask
\par 
\par 
\par \hich\af0\dbch\af17\loch\f0     /* immediate acc instructions */
\par \hich\af0\dbch\af17\loch\f0     task immacc;
\par \hich\af0\dbch\af17\loch\f0     begin
\par \hich\af0\dbch\af17\loch\f0         memread(data, pc);
\par \hich\af0\dbch\af17\loch\f0         pc = pc + 1;
\par \hich\af0\dbch\af17\loch\f0         doacci(data);
\par \hich\af0\dbch\af17\loch\f0     end
\par \hich\af0\dbch\af17\loch\f0     endtask
\par 
\par 
\par \hich\af0\dbch\af17\loch\f0     /* operate on accumulator */
\par \hich\af0\dbch\af17\loch\f0   \hich\af0\dbch\af17\loch\f0   task doacci;
\par \hich\af0\dbch\af17\loch\f0     input[7:0] sr;
\par \hich\af0\dbch\af17\loch\f0     reg[3:0] null4;
\par \hich\af0\dbch\af17\loch\f0     reg[7:0] null8;
\par \hich\af0\dbch\af17\loch\f0         case(ir[5:3])
\par \hich\af0\dbch\af17\loch\f0             0: // ADD ADI
\par \hich\af0\dbch\af17\loch\f0                 begin
\par \hich\af0\dbch\af17\loch\f0                     \{cac, null4\} = acc + sr;
\par \hich\af0\dbch\af17\loch\f0                     \{cc, acc\} = \{1'b0, acc\} + sr;
\par \hich\af0\dbch\af17\loch\f0                  \hich\af0\dbch\af17\loch\f0    calpsz(acc);
\par \hich\af0\dbch\af17\loch\f0                 end
\par 
\par \hich\af0\dbch\af17\loch\f0             1: // ADC ACI
\par \hich\af0\dbch\af17\loch\f0                 begin
\par \hich\af0\dbch\af17\loch\f0                     \{cac, null4\} = acc + sr + cc;
\par \hich\af0\dbch\af17\loch\f0                     \{cc, acc\} = \{1'b0, acc\} + sr + cc;
\par \hich\af0\dbch\af17\loch\f0                     calpsz(acc);
\par \hich\af0\dbch\af17\loch\f0                 end
\par 
\par \hich\af0\dbch\af17\loch\f0             \hich\af0\dbch\af17\loch\f0 2: // SUB SUI
\par \hich\af0\dbch\af17\loch\f0                 begin
\par \hich\af0\dbch\af17\loch\f0                     \{cac, null4\} = acc - sr;
\par \hich\af0\dbch\af17\loch\f0                     \{cc, acc\} = \{1'b0, acc\} - sr;
\par \hich\af0\dbch\af17\loch\f0                     calpsz(acc);
\par \hich\af0\dbch\af17\loch\f0                 end
\par 
\par \hich\af0\dbch\af17\loch\f0             3: // SBB SBI
\par \hich\af0\dbch\af17\loch\f0                 begin
\par \hich\af0\dbch\af17\loch\f0                     \{ca\hich\af0\dbch\af17\loch\f0 c, null4\} = acc - sr - cc;
\par \hich\af0\dbch\af17\loch\f0                     \{cc, acc\} = \{1'b0, acc\} - sr - cc;
\par \hich\af0\dbch\af17\loch\f0                     calpsz(acc);
\par \hich\af0\dbch\af17\loch\f0                 end
\par 
\par \hich\af0\dbch\af17\loch\f0             4: // ANA ANI
\par \hich\af0\dbch\af17\loch\f0                 begin
\par \hich\af0\dbch\af17\loch\f0                     acc = acc & sr;
\par \hich\af0\dbch\af17\loch\f0                     cac = 1;
\par \hich\af0\dbch\af17\loch\f0        \hich\af0\dbch\af17\loch\f0              cc = 0;
\par \hich\af0\dbch\af17\loch\f0                     calpsz(acc);
\par \hich\af0\dbch\af17\loch\f0                 end
\par 
\par \hich\af0\dbch\af17\loch\f0             5: // XRA XRI
\par \hich\af0\dbch\af17\loch\f0                 begin
\par \hich\af0\dbch\af17\loch\f0                     acc = acc ^ sr;
\par \hich\af0\dbch\af17\loch\f0                     cac = 0;
\par \hich\af0\dbch\af17\loch\f0                     cc = 0;
\par \hich\af0\dbch\af17\loch\f0                     calpsz(acc);
\par \hich\af0\dbch\af17\loch\f0        \hich\af0\dbch\af17\loch\f0          end
\par 
\par \hich\af0\dbch\af17\loch\f0             6: // ORA ORI
\par \hich\af0\dbch\af17\loch\f0                 begin
\par \hich\af0\dbch\af17\loch\f0                     acc = acc | sr;
\par \hich\af0\dbch\af17\loch\f0                     cac = 0;
\par \hich\af0\dbch\af17\loch\f0                     cc = 0;
\par \hich\af0\dbch\af17\loch\f0                     calpsz(acc);
\par \hich\af0\dbch\af17\loch\f0                 end
\par 
\par \hich\af0\dbch\af17\loch\f0             7: // CMP CPI
\par \hich\af0\dbch\af17\loch\f0                 begin
\par \hich\af0\dbch\af17\loch\f0                     \{cac, null4\} = acc - sr;
\par \hich\af0\dbch\af17\loch\f0                     \{cc, null8\} = \{1'b0, acc\} - sr;
\par \hich\af0\dbch\af17\loch\f0                     calpsz(null8);
\par \hich\af0\dbch\af17\loch\f0                 end
\par \hich\af0\dbch\af17\loch\f0         endcase
\par \hich\af0\dbch\af17\loch\f0     endtask
\par 
\par \hich\af0\dbch\af17\loch\f0     /* rotate acc and special instructions */
\par \hich\af0\dbch\af17\loch\f0     task racc_spec;
\par \hich\af0\dbch\af17\loch\f0         \hich\af0\dbch\af17\loch\f0 case(ir[5:3])
\par \hich\af0\dbch\af17\loch\f0             0: // RLC
\par \hich\af0\dbch\af17\loch\f0                 begin
\par \hich\af0\dbch\af17\loch\f0                     acc = \{acc[6:0], acc[7]\};
\par \hich\af0\dbch\af17\loch\f0                     cc = acc[7];
\par \hich\af0\dbch\af17\loch\f0                 end
\par 
\par \hich\af0\dbch\af17\loch\f0             1: // RRC
\par \hich\af0\dbch\af17\loch\f0                 begin
\par \hich\af0\dbch\af17\loch\f0                     acc = \{acc[0], acc[7:1]\};
\par \hich\af0\dbch\af17\loch\f0         \hich\af0\dbch\af17\loch\f0             cc = acc[0];
\par \hich\af0\dbch\af17\loch\f0                 end
\par 
\par \hich\af0\dbch\af17\loch\f0             2: // RAL
\par \hich\af0\dbch\af17\loch\f0                 \{cc, acc\} = \{acc, cc\};
\par 
\par \hich\af0\dbch\af17\loch\f0             3: // RAR
\par \hich\af0\dbch\af17\loch\f0                 \{acc, cc\} = \{cc, acc\};
\par 
\par \hich\af0\dbch\af17\loch\f0             4: // DAA, decimal adjust
\par \hich\af0\dbch\af17\loch\f0                 begin
\par \hich\af0\dbch\af17\loch\f0                     if((ac\hich\af0\dbch\af17\loch\f0 c[3:0] > 9) || cac) acc = acc + 6;
\par \hich\af0\dbch\af17\loch\f0                     if((acc[7:4] > 9) || cc) \{cc, acc\} = \{1'b0, acc\} + 'h60;
\par \hich\af0\dbch\af17\loch\f0                 end
\par 
\par \hich\af0\dbch\af17\loch\f0             5: // CMA
\par \hich\af0\dbch\af17\loch\f0                 acc = ~acc;
\par 
\par \hich\af0\dbch\af17\loch\f0             6: // STC
\par \hich\af0\dbch\af17\loch\f0                 cc = 1;
\par 
\par \hich\af0\dbch\af17\loch\f0             7: // CMC
\par \hich\af0\dbch\af17\loch\f0    \hich\af0\dbch\af17\loch\f0              cc = ~cc;
\par \hich\af0\dbch\af17\loch\f0         endcase
\par \hich\af0\dbch\af17\loch\f0     endtask
\par 
\par 
\par \hich\af0\dbch\af17\loch\f0     /* increment and decrement register pair */
\par \hich\af0\dbch\af17\loch\f0     task inx_dcx;
\par \hich\af0\dbch\af17\loch\f0         case(ir[5:3])
\par \hich\af0\dbch\af17\loch\f0             0: \{regb, regc\} = \{regb, regc\} + 1; // INX B
\par \hich\af0\dbch\af17\loch\f0             1: \{regb, regc\} = \{regb, regc\} - 1; // DCX B
\par \hich\af0\dbch\af17\loch\f0  \hich\af0\dbch\af17\loch\f0            2: \{regd, rege\} = \{regd, rege\} + 1; // INX D
\par \hich\af0\dbch\af17\loch\f0             3: \{regd, rege\} = \{regd, rege\} - 1; // DCX D
\par \hich\af0\dbch\af17\loch\f0             4: \{regh, regl\} = \{regh, regl\} + 1; // INX H
\par \hich\af0\dbch\af17\loch\f0             5: \{regh, regl\} = \{regh, regl\} - 1; // DCX H
\par \hich\af0\dbch\af17\loch\f0             6: sp = sp + 1;  \hich\af0\dbch\af17\loch\f0                    // INX SP
\par \hich\af0\dbch\af17\loch\f0             7: sp = sp - 1;                     // DCX SP
\par \hich\af0\dbch\af17\loch\f0         endcase
\par \hich\af0\dbch\af17\loch\f0     endtask
\par 
\par \hich\af0\dbch\af17\loch\f0     /* load register pair immediate */
\par \hich\af0\dbch\af17\loch\f0     task lrpi;
\par \hich\af0\dbch\af17\loch\f0         case(ir[5:4])
\par \hich\af0\dbch\af17\loch\f0             0: adread(\{regb, regc\}); // LXI B
\par \hich\af0\dbch\af17\loch\f0             1: adr\hich\af0\dbch\af17\loch\f0 ead(\{regd, rege\}); // LXI D
\par \hich\af0\dbch\af17\loch\f0             2: adread(\{regh, regl\}); // LXI H
\par \hich\af0\dbch\af17\loch\f0             3: adread(sp);           // LXI SP
\par \hich\af0\dbch\af17\loch\f0         endcase
\par \hich\af0\dbch\af17\loch\f0     endtask
\par 
\par 
\par \hich\af0\dbch\af17\loch\f0     /* add into regh, regl pair */
\par \hich\af0\dbch\af17\loch\f0     task addhl;
\par \hich\af0\dbch\af17\loch\f0     begin
\par \hich\af0\dbch\af17\loch\f0         case(ir[5:4])
\par \hich\af0\dbch\af17\loch\f0             0: \{cc, re\hich\af0\dbch\af17\loch\f0 gh, regl\} = \{1'b0, regh, regl\} + \{regb, regc\}; // DAD B
\par \hich\af0\dbch\af17\loch\f0             1: \{cc, regh, regl\} = \{1'b0, regh, regl\} + \{regd, rege\}; // DAD D
\par \hich\af0\dbch\af17\loch\f0             2: \{cc, regh, regl\} = \{1'b0, regh, regl\} + \{regh, regl\}; // DAD H
\par \hich\af0\dbch\af17\loch\f0             3: \{cc, regh, regl\} = \{1'b0, reg\hich\af0\dbch\af17\loch\f0 h, regl\} + sp;           // DAD SP
\par \hich\af0\dbch\af17\loch\f0         endcase
\par \hich\af0\dbch\af17\loch\f0         holdreq;
\par \hich\af0\dbch\af17\loch\f0         holdreq;
\par \hich\af0\dbch\af17\loch\f0     end
\par \hich\af0\dbch\af17\loch\f0     endtask
\par 
\par 
\par \hich\af0\dbch\af17\loch\f0     /* store and load instruction */
\par \hich\af0\dbch\af17\loch\f0     task sta_lda;
\par \hich\af0\dbch\af17\loch\f0     reg[15:0] ra;
\par \hich\af0\dbch\af17\loch\f0         case(ir[5:3])
\par \hich\af0\dbch\af17\loch\f0             0: memwrite(acc, \{regb, regc\}); // STAX B
\par \hich\af0\dbch\af17\loch\f0             1: memread(acc, \{regb, regc\});  // LDAX B
\par \hich\af0\dbch\af17\loch\f0             2: memwrite(acc, \{regd, rege\}); // STAX D
\par \hich\af0\dbch\af17\loch\f0             3: memread(acc, \{regd, rege\});  // LDAX D
\par 
\par \hich\af0\dbch\af17\loch\f0             4: // SHLD
\par \hich\af0\dbch\af17\loch\f0                 begin
\par \hich\af0\dbch\af17\loch\f0                     adread(ra);
\par \hich\af0\dbch\af17\loch\f0                 \hich\af0\dbch\af17\loch\f0     memwrite(regl, ra);
\par \hich\af0\dbch\af17\loch\f0                     memwrite(regh, ra + 1);
\par \hich\af0\dbch\af17\loch\f0                 end
\par \hich\af0\dbch\af17\loch\f0             5: // LHLD
\par \hich\af0\dbch\af17\loch\f0                 begin
\par \hich\af0\dbch\af17\loch\f0                     adread(ra);
\par \hich\af0\dbch\af17\loch\f0                     memread(regl, ra);
\par \hich\af0\dbch\af17\loch\f0                     memread(regh, ra + 1);
\par \hich\af0\dbch\af17\loch\f0          \hich\af0\dbch\af17\loch\f0        end
\par 
\par \hich\af0\dbch\af17\loch\f0             6: // STA
\par \hich\af0\dbch\af17\loch\f0                 begin
\par \hich\af0\dbch\af17\loch\f0                     adread(ra);
\par \hich\af0\dbch\af17\loch\f0                     memwrite(acc, ra);
\par \hich\af0\dbch\af17\loch\f0                 end
\par \hich\af0\dbch\af17\loch\f0             7: // LDA
\par \hich\af0\dbch\af17\loch\f0                 begin
\par \hich\af0\dbch\af17\loch\f0                     adread(ra);
\par \hich\af0\dbch\af17\loch\f0                     memread(acc, \hich\af0\dbch\af17\loch\f0 ra);
\par \hich\af0\dbch\af17\loch\f0                 end
\par \hich\af0\dbch\af17\loch\f0         endcase
\par \hich\af0\dbch\af17\loch\f0     endtask
\par 
\par \hich\af0\dbch\af17\loch\f0     /* push register pair from stack */
\par \hich\af0\dbch\af17\loch\f0     task push;
\par \hich\af0\dbch\af17\loch\f0         case(ir[5:4])
\par \hich\af0\dbch\af17\loch\f0             0: push2b(regb, regc); // PUSH B
\par \hich\af0\dbch\af17\loch\f0             1: push2b(regd, rege); // PUSH D
\par \hich\af0\dbch\af17\loch\f0             2: push2b(regh, regl); \hich\af0\dbch\af17\loch\f0 // PUSH H
\par \hich\af0\dbch\af17\loch\f0             3: push2b(acc, \{cs,cz,1'b1,cac,1'b1,cp,1'b1,cc\}); // PUSH PSW
\par \hich\af0\dbch\af17\loch\f0         endcase
\par \hich\af0\dbch\af17\loch\f0     endtask
\par 
\par \hich\af0\dbch\af17\loch\f0     /* push 2 bytes onto stack */
\par \hich\af0\dbch\af17\loch\f0     task push2b;
\par \hich\af0\dbch\af17\loch\f0     input[7:0] highb, lowb;
\par \hich\af0\dbch\af17\loch\f0     begin
\par \hich\af0\dbch\af17\loch\f0         sp = sp - 1;
\par \hich\af0\dbch\af17\loch\f0         memwrite(highb, sp);
\par \hich\af0\dbch\af17\loch\f0     \hich\af0\dbch\af17\loch\f0     sp = sp - 1;
\par \hich\af0\dbch\af17\loch\f0         memwrite(lowb, sp);
\par \hich\af0\dbch\af17\loch\f0     end
\par \hich\af0\dbch\af17\loch\f0     endtask
\par 
\par 
\par \hich\af0\dbch\af17\loch\f0     /* pop register pair from stack */
\par \hich\af0\dbch\af17\loch\f0     task pop;
\par \hich\af0\dbch\af17\loch\f0     reg null1;
\par \hich\af0\dbch\af17\loch\f0         case(ir[5:4])
\par \hich\af0\dbch\af17\loch\f0             0: pop2b(regb, regc); // POP B
\par \hich\af0\dbch\af17\loch\f0             1: pop2b(regd, rege); // POP D
\par \hich\af0\dbch\af17\loch\f0             2\hich\af0\dbch\af17\loch\f0 : pop2b(regh, regl); // POP H
\par \hich\af0\dbch\af17\loch\f0             3: pop2b(acc,
\par \hich\af0\dbch\af17\loch\f0                 \{cs, cz, null1, cac, null1, cp, null1, cc\}); // POP PSW
\par \hich\af0\dbch\af17\loch\f0         endcase
\par \hich\af0\dbch\af17\loch\f0     endtask
\par 
\par \hich\af0\dbch\af17\loch\f0     /* pop 2 bytes from stack */
\par \hich\af0\dbch\af17\loch\f0     task pop2b;
\par \hich\af0\dbch\af17\loch\f0     output[7:0] highb, lowb;
\par \hich\af0\dbch\af17\loch\f0     begin
\par \hich\af0\dbch\af17\loch\f0         mem\hich\af0\dbch\af17\loch\f0 read(lowb, sp);
\par \hich\af0\dbch\af17\loch\f0         sp = sp + 1;
\par \hich\af0\dbch\af17\loch\f0         memread(highb, sp);
\par \hich\af0\dbch\af17\loch\f0         sp = sp + 1;
\par \hich\af0\dbch\af17\loch\f0     end
\par \hich\af0\dbch\af17\loch\f0     endtask
\par 
\par \hich\af0\dbch\af17\loch\f0     /* check hold request */
\par \hich\af0\dbch\af17\loch\f0     task holdreq;
\par \hich\af0\dbch\af17\loch\f0     begin
\par \hich\af0\dbch\af17\loch\f0         aleff = 0;
\par \hich\af0\dbch\af17\loch\f0         s0ff = 0;
\par \hich\af0\dbch\af17\loch\f0         s1ff = 1;
\par \hich\af0\dbch\af17\loch\f0         iomff = 0;
\par \hich\af0\dbch\af17\loch\f0         addr = pc;
\par \hich\af0\dbch\af17\loch\f0         if(hold) begin
\par \hich\af0\dbch\af17\loch\f0             holdff = 1;
\par \hich\af0\dbch\af17\loch\f0             acontrol = 0;
\par \hich\af0\dbch\af17\loch\f0             dcontrol = 0;
\par \hich\af0\dbch\af17\loch\f0             @ec2 hldaff = 1;
\par \hich\af0\dbch\af17\loch\f0         end
\par \hich\af0\dbch\af17\loch\f0         else begin
\par \hich\af0\dbch\af17\loch\f0             acontrol = 1;
\par \hich\af0\dbch\af17\loch\f0             dcontrol = 1;
\par \hich\af0\dbch\af17\loch\f0         end
\par \hich\af0\dbch\af17\loch\f0         @ec1 dcontrol = 0;
\par \hich\af0\dbch\af17\loch\f0      \hich\af0\dbch\af17\loch\f0    @ec1 @ec2;
\par \hich\af0\dbch\af17\loch\f0     end
\par \hich\af0\dbch\af17\loch\f0     endtask
\par 
\par \hich\af0\dbch\af17\loch\f0     /* conditional jump, call and return instructions */
\par \hich\af0\dbch\af17\loch\f0     task condjcr;
\par \hich\af0\dbch\af17\loch\f0     reg branch;
\par \hich\af0\dbch\af17\loch\f0     begin
\par \hich\af0\dbch\af17\loch\f0         case(ir[5:3])
\par \hich\af0\dbch\af17\loch\f0             0: branch = !cz; // JNZ CNZ RNZ
\par \hich\af0\dbch\af17\loch\f0             1: branch = cz;  // JZ  CZ  RZ
\par \hich\af0\dbch\af17\loch\f0            \hich\af0\dbch\af17\loch\f0  2: branch = !cc; // JNC CNC RNC
\par \hich\af0\dbch\af17\loch\f0             3: branch = cc;  // JC  CC  RC
\par \hich\af0\dbch\af17\loch\f0             4: branch = !cp; // JPO CPO RPO
\par \hich\af0\dbch\af17\loch\f0             5: branch = cp;  // JPE CPE RPE
\par \hich\af0\dbch\af17\loch\f0             6: branch = !cs; // JP  CP  RP
\par \hich\af0\dbch\af17\loch\f0             7: branch = cs;  // JM  CM  RM
\par \hich\af0\dbch\af17\loch\f0       \hich\af0\dbch\af17\loch\f0   endcase
\par \hich\af0\dbch\af17\loch\f0         if(branch)
\par \hich\af0\dbch\af17\loch\f0             case(ir[2:0])
\par \hich\af0\dbch\af17\loch\f0                 0: // return
\par \hich\af0\dbch\af17\loch\f0                     pop2b(pc[15:8], pc[7:0]);
\par 
\par \hich\af0\dbch\af17\loch\f0                 2: // jump
\par \hich\af0\dbch\af17\loch\f0                     adread(pc);
\par 
\par \hich\af0\dbch\af17\loch\f0                 4: // call
\par \hich\af0\dbch\af17\loch\f0                     begin :call
\par \hich\af0\dbch\af17\loch\f0       \hich\af0\dbch\af17\loch\f0                   reg [15:0] newpc;
\par \hich\af0\dbch\af17\loch\f0                         adread(newpc);
\par \hich\af0\dbch\af17\loch\f0                         push2b(pc[15:8], pc[7:0]);
\par \hich\af0\dbch\af17\loch\f0                         pc = newpc;
\par \hich\af0\dbch\af17\loch\f0                     end
\par 
\par \hich\af0\dbch\af17\loch\f0                 default no_instruction;
\par \hich\af0\dbch\af17\loch\f0             endcase
\par \hich\af0\dbch\af17\loch\f0         e\hich\af0\dbch\af17\loch\f0 lse
\par \hich\af0\dbch\af17\loch\f0             case(ir[2:0])
\par \hich\af0\dbch\af17\loch\f0                 0: ;
\par \hich\af0\dbch\af17\loch\f0                 2, 4:
\par \hich\af0\dbch\af17\loch\f0                     begin
\par \hich\af0\dbch\af17\loch\f0                         memread(data, pc);
\par \hich\af0\dbch\af17\loch\f0                         pc = pc + 2;
\par \hich\af0\dbch\af17\loch\f0                     end
\par \hich\af0\dbch\af17\loch\f0                 default no_instruction;
\par \hich\af0\dbch\af17\loch\f0             e\hich\af0\dbch\af17\loch\f0 ndcase
\par \hich\af0\dbch\af17\loch\f0     end
\par \hich\af0\dbch\af17\loch\f0     endtask
\par 
\par 
\par \hich\af0\dbch\af17\loch\f0     /* restart instructions */
\par \hich\af0\dbch\af17\loch\f0     task restart;
\par \hich\af0\dbch\af17\loch\f0     begin
\par \hich\af0\dbch\af17\loch\f0         push2b(pc[15:8], pc[7:0]);
\par \hich\af0\dbch\af17\loch\f0         case(ir[5:3])
\par \hich\af0\dbch\af17\loch\f0             0: pc = 'h00; // RST 0
\par \hich\af0\dbch\af17\loch\f0             1: pc = 'h08; // RST 1
\par \hich\af0\dbch\af17\loch\f0             2: pc = 'h10; // RST 2
\par \hich\af0\dbch\af17\loch\f0       \hich\af0\dbch\af17\loch\f0       3: pc = 'h18; // RST 3
\par \hich\af0\dbch\af17\loch\f0             4: pc = 'h20; // RST 4
\par \hich\af0\dbch\af17\loch\f0             5: pc = 'h28; // RST 5
\par \hich\af0\dbch\af17\loch\f0             6: pc = 'h30; // RST 6
\par \hich\af0\dbch\af17\loch\f0             7: pc = 'h38; // RST 7
\par \hich\af0\dbch\af17\loch\f0         endcase
\par \hich\af0\dbch\af17\loch\f0     end
\par \hich\af0\dbch\af17\loch\f0     endtask
\par 
\par 
\par \hich\af0\dbch\af17\loch\f0     /* new instructions - except for NOP */
\par \hich\af0\dbch\af17\loch\f0     t\hich\af0\dbch\af17\loch\f0 ask newops;
\par \hich\af0\dbch\af17\loch\f0         case(ir[5:3])
\par \hich\af0\dbch\af17\loch\f0             0: ; // NOP
\par 
\par \hich\af0\dbch\af17\loch\f0             4: // RIM
\par \hich\af0\dbch\af17\loch\f0                 begin
\par \hich\af0\dbch\af17\loch\f0                     acc = \{sid, intmask[7:5], intmask[3:0]\};
\par \hich\af0\dbch\af17\loch\f0                     if(trapi) begin
\par \hich\af0\dbch\af17\loch\f0                         intmask[3] = inte;
\par \hich\af0\dbch\af17\loch\f0              \hich\af0\dbch\af17\loch\f0            trapi = 0;
\par \hich\af0\dbch\af17\loch\f0                     end
\par \hich\af0\dbch\af17\loch\f0                 end
\par 
\par \hich\af0\dbch\af17\loch\f0             6: // SIM
\par \hich\af0\dbch\af17\loch\f0                 begin
\par \hich\af0\dbch\af17\loch\f0                     if(acc[3]) begin
\par \hich\af0\dbch\af17\loch\f0                         intmask[2:0] = acc[2:0];
\par \hich\af0\dbch\af17\loch\f0                         intmask[6:5] = intmask[6:5] & acc[1\hich\af0\dbch\af17\loch\f0 :0];
\par \hich\af0\dbch\af17\loch\f0                     end
\par \hich\af0\dbch\af17\loch\f0                     intmask[8] = acc[4];
\par \hich\af0\dbch\af17\loch\f0                     if(acc[6]) @ec1 @ec1 @ec2 sodff = acc[7];
\par \hich\af0\dbch\af17\loch\f0                 end
\par 
\par \hich\af0\dbch\af17\loch\f0             default no_instruction;
\par \hich\af0\dbch\af17\loch\f0         endcase
\par \hich\af0\dbch\af17\loch\f0     endtask
\par 
\par 
\par \hich\af0\dbch\af17\loch\f0     /* decode 1 instructions */
\par \hich\af0\dbch\af17\loch\f0     t\hich\af0\dbch\af17\loch\f0 ask decode1;
\par \hich\af0\dbch\af17\loch\f0         case(ir[5:4])
\par \hich\af0\dbch\af17\loch\f0             0: pop2b(pc[15:8], pc[7:0]); // RET
\par \hich\af0\dbch\af17\loch\f0             2: pc = \{regh, regl\}; // PCHL
\par \hich\af0\dbch\af17\loch\f0             3: sp = \{regh, regl\}; // SPHL
\par \hich\af0\dbch\af17\loch\f0             default no_instruction;
\par \hich\af0\dbch\af17\loch\f0         endcase
\par \hich\af0\dbch\af17\loch\f0     endtask
\par 
\par 
\par \hich\af0\dbch\af17\loch\f0     /* decode 2 instruc\hich\af0\dbch\af17\loch\f0 tions */
\par \hich\af0\dbch\af17\loch\f0     task decode2;
\par \hich\af0\dbch\af17\loch\f0     reg[7:0] saveh, savel;
\par \hich\af0\dbch\af17\loch\f0         case(ir[5:3])
\par \hich\af0\dbch\af17\loch\f0             0: adread(pc); // JMP
\par 
\par \hich\af0\dbch\af17\loch\f0             2: // OUT
\par \hich\af0\dbch\af17\loch\f0                 begin
\par \hich\af0\dbch\af17\loch\f0                     memread(data, pc);
\par \hich\af0\dbch\af17\loch\f0                     pc = pc + 1;
\par \hich\af0\dbch\af17\loch\f0                     iowrite(d\hich\af0\dbch\af17\loch\f0 ata);
\par \hich\af0\dbch\af17\loch\f0                 end
\par 
\par \hich\af0\dbch\af17\loch\f0             3: // IN
\par \hich\af0\dbch\af17\loch\f0                 begin
\par \hich\af0\dbch\af17\loch\f0                     memread(data, pc);
\par \hich\af0\dbch\af17\loch\f0                     pc = pc + 1;
\par \hich\af0\dbch\af17\loch\f0                     ioread(data);
\par \hich\af0\dbch\af17\loch\f0                 end
\par 
\par \hich\af0\dbch\af17\loch\f0             4: // XTHL
\par \hich\af0\dbch\af17\loch\f0                 begin
\par \hich\af0\dbch\af17\loch\f0               \hich\af0\dbch\af17\loch\f0       saveh = regh;
\par \hich\af0\dbch\af17\loch\f0                     savel = regl;
\par \hich\af0\dbch\af17\loch\f0                     pop2b(regh, regl);
\par \hich\af0\dbch\af17\loch\f0                     push2b(saveh, savel);
\par \hich\af0\dbch\af17\loch\f0                 end
\par 
\par \hich\af0\dbch\af17\loch\f0             5: // XCHG
\par \hich\af0\dbch\af17\loch\f0                 begin
\par \hich\af0\dbch\af17\loch\f0                     saveh = regh;
\par \hich\af0\dbch\af17\loch\f0                     s\hich\af0\dbch\af17\loch\f0 avel = regl;
\par \hich\af0\dbch\af17\loch\f0                     regh = regd;
\par \hich\af0\dbch\af17\loch\f0                     regl = rege;
\par \hich\af0\dbch\af17\loch\f0                     regd = saveh;
\par \hich\af0\dbch\af17\loch\f0                     rege = savel;
\par \hich\af0\dbch\af17\loch\f0                 end
\par 
\par \hich\af0\dbch\af17\loch\f0             6: // DI, disable interrupt
\par \hich\af0\dbch\af17\loch\f0                 \{intmask[6:5], intmask[3]\} = 0;
\par 
\par \hich\af0\dbch\af17\loch\f0             7: // EI, enable interrupt
\par \hich\af0\dbch\af17\loch\f0                 intmask[3] = 1;
\par 
\par \hich\af0\dbch\af17\loch\f0             default no_instruction;
\par \hich\af0\dbch\af17\loch\f0         endcase
\par \hich\af0\dbch\af17\loch\f0     endtask
\par 
\par 
\par \hich\af0\dbch\af17\loch\f0     /* decode 3 instructions */
\par \hich\af0\dbch\af17\loch\f0     task decode3;
\par \hich\af0\dbch\af17\loch\f0         case(ir[5:4])
\par \hich\af0\dbch\af17\loch\f0             0: // CALL
\par \hich\af0\dbch\af17\loch\f0                 begin \hich\af0\dbch\af17\loch\f0 :call
\par \hich\af0\dbch\af17\loch\f0                     reg [15:0] newpc;
\par \hich\af0\dbch\af17\loch\f0                     adread(newpc);
\par \hich\af0\dbch\af17\loch\f0                     push2b(pc[15:8], pc[7:0]);
\par \hich\af0\dbch\af17\loch\f0                     pc = newpc;
\par \hich\af0\dbch\af17\loch\f0                 end
\par 
\par \hich\af0\dbch\af17\loch\f0             default no_instruction;
\par \hich\af0\dbch\af17\loch\f0         endcase
\par \hich\af0\dbch\af17\loch\f0     endtask
\par 
\par 
\par \hich\af0\dbch\af17\loch\f0     /* fetc\hich\af0\dbch\af17\loch\f0 h address from pc+1, pc+2 */
\par \hich\af0\dbch\af17\loch\f0     task adread;
\par \hich\af0\dbch\af17\loch\f0     output[15:0] address;
\par \hich\af0\dbch\af17\loch\f0     begin
\par \hich\af0\dbch\af17\loch\f0         memread(address[7:0], pc);
\par \hich\af0\dbch\af17\loch\f0         pc = pc + 1;
\par \hich\af0\dbch\af17\loch\f0         memread(address[15:8], pc);
\par \hich\af0\dbch\af17\loch\f0         if(!int) pc = pc + 1;
\par \hich\af0\dbch\af17\loch\f0     end
\par \hich\af0\dbch\af17\loch\f0     endtask
\par 
\par 
\par \hich\af0\dbch\af17\loch\f0     /* calculate cp cs and cz \hich\af0\dbch\af17\loch\f0 */
\par \hich\af0\dbch\af17\loch\f0     task calpsz;
\par \hich\af0\dbch\af17\loch\f0     input[7:0] tr;
\par \hich\af0\dbch\af17\loch\f0     begin
\par \hich\af0\dbch\af17\loch\f0         cp = ^tr;
\par \hich\af0\dbch\af17\loch\f0         cz = tr == 0;
\par \hich\af0\dbch\af17\loch\f0         cs = tr[7];
\par \hich\af0\dbch\af17\loch\f0     end
\par \hich\af0\dbch\af17\loch\f0     endtask
\par 
\par 
\par \hich\af0\dbch\af17\loch\f0     /* undefined instruction */
\par \hich\af0\dbch\af17\loch\f0     task no_instruction;
\par \hich\af0\dbch\af17\loch\f0     begin
\par \hich\af0\dbch\af17\loch\f0         $display("Undefined instruction");
\par \hich\af0\dbch\af17\loch\f0         dumpsta\hich\af0\dbch\af17\loch\f0 te;
\par \hich\af0\dbch\af17\loch\f0         $finish;
\par \hich\af0\dbch\af17\loch\f0     end
\par \hich\af0\dbch\af17\loch\f0     endtask
\par 
\par 
\par \hich\af0\dbch\af17\loch\f0     /* print the state of the 8085a */
\par \hich\af0\dbch\af17\loch\f0     task dumpstate;
\par \hich\af0\dbch\af17\loch\f0     begin
\par \hich\af0\dbch\af17\loch\f0         $write( "\\nDUMP OF 8085A REGISTERS\\n",
\par \hich\af0\dbch\af17\loch\f0             "acc=%h regb=%h regc=%h regd=%h rege=%h regh=%h regl=%h\\n",
\par \hich\af0\dbch\af17\loch\f0                 acc, regb\hich\af0\dbch\af17\loch\f0 , regc, regd, rege, regh, regl,
\par \hich\af0\dbch\af17\loch\f0             "cs=%h cz=%h cac=%h cp=%h cc=%h\\n",
\par \hich\af0\dbch\af17\loch\f0                 cs, cz, cac, cp, cc,
\par \hich\af0\dbch\af17\loch\f0             "pc=%h sp=%h addr=%h ir=%h data=%h\\n",
\par \hich\af0\dbch\af17\loch\f0                 pc, sp, ir, addr, data,
\par \hich\af0\dbch\af17\loch\f0             "intmask=%h aleff=%h s0ff=%h s1ff=%h\hich\af0\dbch\af17\loch\f0  hldaff=%h holdff=%h\\n",
\par \hich\af0\dbch\af17\loch\f0                 intmask, aleff, s0ff, s1ff, hldaff, holdff,
\par \hich\af0\dbch\af17\loch\f0             "intaff=%h trapff=%h trapi=%h inte=%h int=%h validint=%h\\n",
\par \hich\af0\dbch\af17\loch\f0                 intaff, trapff, trapi, inte, int, validint,
\par \hich\af0\dbch\af17\loch\f0             "haltff=%h resetff=%h cloc\hich\af0\dbch\af17\loch\f0 kff=%h sodff=%h\\n",
\par \hich\af0\dbch\af17\loch\f0                 haltff, resetff, clockff, sodff,
\par \hich\af0\dbch\af17\loch\f0             "read=%h write=%h iomff=%h acontrol=%h dcontrol=%h s=%h\\n",
\par \hich\af0\dbch\af17\loch\f0                 read, write, iomff, acontrol, dcontrol, s,
\par \hich\af0\dbch\af17\loch\f0             "clock=%h x2=%h sid=%h trap=%h rst7p5=%h rst\hich\af0\dbch\af17\loch\f0 6p5=%h rst5p5=%h\\n",
\par \hich\af0\dbch\af17\loch\f0                 clock, x2, sid, trap, rst7p5, rst6p5, rst5p5,
\par \hich\af0\dbch\af17\loch\f0             "intr=%h nreset=%h hold=%h ready=%h a=%h ad=%h\\n\\n",
\par \hich\af0\dbch\af17\loch\f0                 intr, nreset, hold, ready, a, ad,
\par \hich\af0\dbch\af17\loch\f0             "instructions executed = %d\\n\\n", instruction)\hich\af0\dbch\af17\loch\f0 ;
\par \hich\af0\dbch\af17\loch\f0     end
\par \hich\af0\dbch\af17\loch\f0     endtask
\par 
\par \hich\af0\dbch\af17\loch\f0 endmodule /* of i85 */  
\par 
\par \hich\af0\dbch\af17\loch\f0 //+++++++++++++++++++++++++++++++++++++++\hich\af0\dbch\af17\loch\f0 ++++++++++++++++++++++++++++}{\f0 
\par }}